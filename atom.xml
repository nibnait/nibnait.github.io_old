<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一只正在爬坡的Java狗</title>
  <subtitle>知之为知之</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nibnait.com/"/>
  <updated>2016-09-22T09:08:23.437Z</updated>
  <id>http://nibnait.com/</id>
  
  <author>
    <name>NibNait</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>求最长回文子串的Manacher算法</title>
    <link href="http://nibnait.com/Manacher/"/>
    <id>http://nibnait.com/Manacher/</id>
    <published>2016-09-19T07:40:52.000Z</published>
    <updated>2016-09-22T09:08:23.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目：-给定一个字符串，求它的最长回文子串长度。"><a href="#题目：-给定一个字符串，求它的最长回文子串长度。" class="headerlink" title="题目： 给定一个字符串，求它的最长回文子串长度。"></a>题目： 给定一个字符串，求它的最长回文子串长度。</h1><h2 id="1-暴力出奇迹"><a href="#1-暴力出奇迹" class="headerlink" title="1. 暴力出奇迹"></a>1. 暴力出奇迹</h2><p>求出字符串n的所有字串（O(N^2)），然后判断每个字符串是否为回文串（O(N)）。<br>    时间复杂度：O(N^3)</p>
<h2 id="2-根据回文串都是对称的特性"><a href="#2-根据回文串都是对称的特性" class="headerlink" title="2. 根据回文串都是对称的特性"></a>2. 根据回文串都是对称的特性</h2><p>分别以每个字符串（奇数个字符）或者两个字符串中间的位置（偶数个字符），向两边扩，直到无法再扩，记下长度。因为这样的位置一共有（2N+1）个，每个位置上平均要进行N/4次字符的比较，所以此算法的时间复杂度为：O(N^2)</p>
<a id="more"></a>
<h2 id="3-Manacher算法"><a href="#3-Manacher算法" class="headerlink" title="3. Manacher算法"></a>3. Manacher算法</h2><ol>
<li><p>消除奇偶性问题<br> 在每个字符的两边加一个同样的特殊字符，（可以是’#’、也可以是’a’，对最终计算结果无影响。）</p>
<pre><code>例：    
    aba  ———&gt;  #a#b#a#
    abba ———&gt;  #a#b#b#a#
</code></pre></li>
<li><p>解决一定程度上的重复访问问题<br> （马拉车算法的精髓：三个辅助变量：）</p>
<ul>
<li>pArr[i]：i位置上，所能扩到的最大回文半径</li>
<li>maxRight：记录回文半径所能扫到最右位置。（maxRight = i+pArr[i]-1）</li>
<li><p>index：当maxRight更新的时候，此时回文中心的位置</p>
<p><strong>Manacher算法的核心：利用回文串的对称性，高效的扩展pArr[]。</strong></p>
<ol>
<li><p>当计算到i位置（且i在maxRight的左边）时，j为i关于index的对称位置，所以分为两种情况：<br>a. pArr[j]很短，短到像下图这样：</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com//leanote/img/Manacher%E7%AE%97%E6%B3%95-1.png" alt="Manacher-1"><br>所以以i为对称轴的回文串的回文半径至少为pArr[j]，因此可以将pArr[j]赋给pArr[i]，然后从i+pArr[i]的位置继续扩展</p>
<p>b. 以j为对称轴的回文串很长，这么长：</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com//leanote/img/Manacher%E7%AE%97%E6%B3%95-2.png" alt="Manacher-2"><br>这时 我们只能确定以i为轴时，绿框里面的部分（即不超过maxRight部分）是回文的，于是我们就可以将maxRight-i赋给pArr[i]，从i+pArr[i]位置继续扩展</p>
</li>
<li><p>i在maxRight的右边，此时以i为对称轴的字符串还没有任何部分别访问过，所以只能从i的左右两边开始尝试扩展了，然后更新maxRight和index</p>
</li>
</ol>
<p>代码：</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> * 求 最长回文字串的长度</div><div class="line"> * Created by nibnait on 2016/9/18.</div><div class="line"> */</div><div class="line">public class Manacher &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">//        String str = &quot;tattarrattat&quot;;</div><div class="line">        String str = &quot;cabaddabac&quot;;</div><div class="line">        System.out.println(maxLcpsLength(str));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static int maxLcpsLength(String str) &#123;</div><div class="line">        if (str==null || str.length()==0)&#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        char[] strArr = str.toCharArray();</div><div class="line">        int length = 2*strArr.length+1;</div><div class="line">        char[] charArr = new char[length];</div><div class="line">        charArr[length-1] = &apos;#&apos;;</div><div class="line">        //字符串预处理</div><div class="line">        int cnt = 0;</div><div class="line">        for (int i = 0; i &lt; length-1; ) &#123;</div><div class="line">            charArr[i++] = &apos;#&apos;;</div><div class="line">            charArr[i++] = strArr[cnt++];</div><div class="line">        &#125;</div><div class="line">        int MaxLen = Integer.MIN_VALUE;</div><div class="line">        int[] pArr = new int[length];   //i位置上，所能扩到的最大回文半径</div><div class="line">        int maxRight = -1;      //记录回文半径所能扫到最右位置。（maxRight = i+pArr[i]-1）</div><div class="line">        int index  = -1;        //当maxRight更新的时候，此时回文中心的位置</div><div class="line">        for (int i = 0; i &lt; length; i++) &#123;</div><div class="line">            if (i &lt; maxRight)&#123;</div><div class="line">                pArr[i] = Math.min(pArr[2*index-i], maxRight-i);    //看pArr[j]的长度</div><div class="line">            &#125; else &#123;</div><div class="line">                pArr[i] = 1;    //i在maxRight的右边，从1开始扩</div><div class="line">            &#125;</div><div class="line">            //尝试扩展</div><div class="line">            while (i+pArr[i]&lt;length &amp;&amp; i-pArr[i]&gt;=0 &amp;&amp; charArr[i-pArr[i]]==charArr[i+pArr[i]])&#123;</div><div class="line">                pArr[i]++;</div><div class="line">            &#125;</div><div class="line">            //尝试更新maxRight和index</div><div class="line">            if (i+pArr[i]&gt;maxRight)&#123;</div><div class="line">                maxRight = i+pArr[i]-1;</div><div class="line">                index = i;</div><div class="line">            &#125;</div><div class="line">            MaxLen = Math.max(MaxLen, pArr[i]);</div><div class="line">        &#125;</div><div class="line">        return MaxLen-1;    //因为MaxLen为带有&apos;#&apos;的回文半径，所以不带&apos;#&apos;回文长度也就为MaxLen-1</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="进阶题目：请在一个字符串最后添加最少字符，使整个字符串都成为回文串"><a href="#进阶题目：请在一个字符串最后添加最少字符，使整个字符串都成为回文串" class="headerlink" title="进阶题目：请在一个字符串最后添加最少字符，使整个字符串都成为回文串"></a>进阶题目：请在一个字符串最后添加最少字符，使整个字符串都成为回文串</h1><p>其实就是查找在必须包含最后一个字符的情况下，最长的回文串是什么。那么将之前不是最长回文字串的部分逆序过来，就是应该添加的部分了。</p>
<p>例如：”abcd123321”, 在必须包含最后一个字符的情况下，最长回文字串是”123321”，之前不是回文子串的部分是”abcd”，所以末尾应该添加的部分就是”dcba”。</p>
<p>则可将Manacher算法修改成：当maxRight到达最后时，直接退出，然后返回不包含最后那段回文字串的所有前面的字符串的逆序即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目：-给定一个字符串，求它的最长回文子串长度。&quot;&gt;&lt;a href=&quot;#题目：-给定一个字符串，求它的最长回文子串长度。&quot; class=&quot;headerlink&quot; title=&quot;题目： 给定一个字符串，求它的最长回文子串长度。&quot;&gt;&lt;/a&gt;题目： 给定一个字符串，求它的最长回文子串长度。&lt;/h1&gt;&lt;h2 id=&quot;1-暴力出奇迹&quot;&gt;&lt;a href=&quot;#1-暴力出奇迹&quot; class=&quot;headerlink&quot; title=&quot;1. 暴力出奇迹&quot;&gt;&lt;/a&gt;1. 暴力出奇迹&lt;/h2&gt;&lt;p&gt;求出字符串n的所有字串（O(N^2)），然后判断每个字符串是否为回文串（O(N)）。&lt;br&gt;    时间复杂度：O(N^3)&lt;/p&gt;
&lt;h2 id=&quot;2-根据回文串都是对称的特性&quot;&gt;&lt;a href=&quot;#2-根据回文串都是对称的特性&quot; class=&quot;headerlink&quot; title=&quot;2. 根据回文串都是对称的特性&quot;&gt;&lt;/a&gt;2. 根据回文串都是对称的特性&lt;/h2&gt;&lt;p&gt;分别以每个字符串（奇数个字符）或者两个字符串中间的位置（偶数个字符），向两边扩，直到无法再扩，记下长度。因为这样的位置一共有（2N+1）个，每个位置上平均要进行N/4次字符的比较，所以此算法的时间复杂度为：O(N^2)&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://nibnait.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构与算法" scheme="http://nibnait.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配的KMP算法</title>
    <link href="http://nibnait.com/KMP/"/>
    <id>http://nibnait.com/KMP/</id>
    <published>2016-09-18T07:40:52.000Z</published>
    <updated>2016-09-22T09:09:29.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目：给定字符串str1-和str2，请返回str2-在str1-中第一次出现的位置；如果str1-不包含str2，返回-1"><a href="#题目：给定字符串str1-和str2，请返回str2-在str1-中第一次出现的位置；如果str1-不包含str2，返回-1" class="headerlink" title="题目：给定字符串str1 和str2，请返回str2 在str1 中第一次出现的位置；如果str1 不包含str2，返回-1"></a>题目：给定字符串str1 和str2，请返回str2 在str1 中第一次出现的位置；如果str1 不包含str2，返回-1</h1><h2 id="1-暴力解法"><a href="#1-暴力解法" class="headerlink" title="1. 暴力解法"></a>1. 暴力解法</h2><p>从str1[0]位置开始与str2[0]一个一个匹配，一步一步往下走。<br>    str1的长度为N，str2的长度为M，<br>    则时间复杂度为：O（N*M）</p>
<a id="more"></a>
<h2 id="2-KMP算法"><a href="#2-KMP算法" class="headerlink" title="2. KMP算法"></a>2. KMP算法</h2><p>由于暴力算法，做了很多重复的匹配工作，比如str1=”aaaaaaaaaaaaaaab”，str2=”aaaaaaaab”时，暴力算法简直累死傻小子啊<br>为了尽可能少的进行重复的无意义的比较，下面引入一个nextArr[]</p>
<h3 id="KMP算法的精髓："><a href="#KMP算法的精髓：" class="headerlink" title="KMP算法的精髓："></a>KMP算法的精髓：</h3><pre><code>int nextArr[i]中放的是str2的i位置处，不包含i位置的这个字符，只考察i位置前面的字符串，前缀和后缀相同字符的最大长度。

    前缀：从第一个字符开始向后扩，不包含最后一个字符
    后缀：从最后一个字符向前扩， 不包含第一个字符
</code></pre><h3 id="下面采用一个典型例子，讲解一下KMP算法的流程："><a href="#下面采用一个典型例子，讲解一下KMP算法的流程：" class="headerlink" title="下面采用一个典型例子，讲解一下KMP算法的流程："></a>下面采用一个典型例子，讲解一下KMP算法的流程：</h3><pre><code>str1=&quot;abcdabcdaabcdabac&quot;
str2=&quot;abcdaba&quot;
</code></pre><ol>
<li>挨个字符串比较，当第一次出现不匹配时：str2可以一次性向右移动4位（’a’为str2的第6号元素，nextArr[6]=2，所以向右移动6-2=4位）。【因为str2的’a’位置前面的字符串，相同最长字符的后缀（”ab”）前面的那些字符就不用检查了，必然匹配不出来。如果你还想问这里是为什么？？？对不起，自己试试就知道了】</li>
<li>第二次出现不匹配时，一样，’b’前面的那个后缀’a’前面的字符都不用比了，直接将str2再向后移动4位（’b’是str2的第5号字符，又因为nextArr[5]=1，所以向后移动5-1=4位）从a位置处开始往后比较。</li>
<li>str2的’b’与str1的’a’不匹配，向右移动1位，重新比较。</li>
<li>bingo！ Game Over！return str1中那个’a’的下标。<br>图示：</li>
</ol>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com//leanote/img/KMP%E7%AE%97%E6%B3%95-1.png" alt=""></p>
<h3 id="下面介绍nextArr-的求法："><a href="#下面介绍nextArr-的求法：" class="headerlink" title="下面介绍nextArr[]的求法："></a>下面介绍nextArr[]的求法：</h3><ul>
<li>对于str2[0]来说，在它之前没有字符，所以规定nextArr[0] = -1;</li>
<li>因为前缀不包含最后一个字符，后缀不能包含第一个字符，所以 nextArr[1] = 0;</li>
<li><p>当i&gt;1时，就需要动笔算了：<br> 引入一个cn变量：最长匹配前缀后面那个字符的位置。</p>
<ul>
<li>当遍历到i时，将str2[i-1]与str2[cn]相比较，如果相等，则正好nextArr[i]=nextArr[i-1]+1.</li>
<li>如果不相等，则比较str2[nextArr[cn]]与str2[i-1]，直到cn到达str2[0]的位置。如果还是不与str2[i-1]相等，则nextArr[i] = 0;</li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">private static int[] getNextArray(char[] s2) &#123;</div><div class="line">    if (s2.length == 1)&#123;</div><div class="line">        return new int[]&#123;-1&#125;;</div><div class="line">    &#125;</div><div class="line">    int[] nextArr = new int[s2.length];</div><div class="line">    nextArr[0] = -1;</div><div class="line">    nextArr[1] = 0;</div><div class="line">    int pos = 2;    //当前位置</div><div class="line">    int cn = 0;     //最长匹配前缀的下一个字符的位置</div><div class="line">    while (pos &lt; s2.length)&#123;</div><div class="line">        if (s2[pos-1] == s2[cn])&#123;   </div><div class="line">            nextArr[pos++] = nextArr[pos-1] + 1;</div><div class="line">        &#125;else if (cn &gt; 0)&#123;</div><div class="line">            cn = nextArr[cn];</div><div class="line">        &#125;else &#123;</div><div class="line">            nextArr[pos++] = 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return nextArr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码：<a href="https://github.com/nibnait/algorithms/blob/master/src/nowcoder/a_1st_Season/aa_Manacher_bfprt_KMP/KMP.java" target="_blank" rel="external">https://github.com/nibnait/algorithms/…/KMP.java</a></p>
<p>时间复杂度分析：因为将str2遍历一遍即可求得nextArr[]<br>所以整个KMP算法的时间复杂度即为：O(M)（str2的长度M）+O(N)（匹配过程）,因为N&gt;=M，所以时间复杂度为O(N)。</p>
<p>#扩展题目：给定两棵二叉树的头节点head1 和head2，判断head2 是不是head1 的子树  </p>
<p>将二叉树遍历成字符串咯。</p>
<hr>
<p>再回过头看用KMP查找”aaaaaaaab”在”aaaaaaaaaaaaaaab”中第一次出现的位置：</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目：给定字符串str1-和str2，请返回str2-在str1-中第一次出现的位置；如果str1-不包含str2，返回-1&quot;&gt;&lt;a href=&quot;#题目：给定字符串str1-和str2，请返回str2-在str1-中第一次出现的位置；如果str1-不包含str2，返回-1&quot; class=&quot;headerlink&quot; title=&quot;题目：给定字符串str1 和str2，请返回str2 在str1 中第一次出现的位置；如果str1 不包含str2，返回-1&quot;&gt;&lt;/a&gt;题目：给定字符串str1 和str2，请返回str2 在str1 中第一次出现的位置；如果str1 不包含str2，返回-1&lt;/h1&gt;&lt;h2 id=&quot;1-暴力解法&quot;&gt;&lt;a href=&quot;#1-暴力解法&quot; class=&quot;headerlink&quot; title=&quot;1. 暴力解法&quot;&gt;&lt;/a&gt;1. 暴力解法&lt;/h2&gt;&lt;p&gt;从str1[0]位置开始与str2[0]一个一个匹配，一步一步往下走。&lt;br&gt;    str1的长度为N，str2的长度为M，&lt;br&gt;    则时间复杂度为：O（N*M）&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://nibnait.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构与算法" scheme="http://nibnait.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>经典数据库SQL语句编写练习题——SQL语句扫盲</title>
    <link href="http://nibnait.com/2cde884b-SqlStatements-eliminate-illiteracy/"/>
    <id>http://nibnait.com/2cde884b-SqlStatements-eliminate-illiteracy/</id>
    <published>2016-07-15T16:23:12.000Z</published>
    <updated>2016-08-08T15:19:43.363Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：</p>
<ul>
<li><a href="http://blog.csdn.net/wolfofsiberian/article/details/39346781" target="_blank" rel="external">http://blog.csdn.net/wolfofsiberian/article/details/39346781</a></li>
<li>SQL总结（一）基本查询：<a href="http://www.imooc.com/article/1412" target="_blank" rel="external">http://www.imooc.com/article/1412</a></li>
</ul>
<a id="more"></a>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/2cde884b-1.png" alt=""></p>
<p>建表语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">use test;  </div><div class="line">  </div><div class="line">create table student  </div><div class="line">(  </div><div class="line">    SNO varchar(20) primary key,  </div><div class="line">    SNAME varchar(20) character set gbk,  </div><div class="line">    AGE int,  </div><div class="line">    SEX  char(2) character set gbk CHECK(SEX IN(&apos;男&apos;,&apos;女&apos;))   </div><div class="line">);  </div><div class="line">insert into student values(&apos;1&apos;,&apos;李强&apos;,23,&apos;男&apos;);  </div><div class="line">insert into student values(&apos;2&apos;,&apos;刘丽&apos;,22,&apos;女&apos;);  </div><div class="line">insert into student values(&apos;5&apos;,&apos;张友&apos;,22,&apos;男&apos;);  </div><div class="line">  </div><div class="line">create table course  </div><div class="line">(  </div><div class="line">    CNO varchar(20) primary key,  </div><div class="line">    CNAME varchar(20) character set gbk,  </div><div class="line">    TEACHER varchar(20) character set gbk  </div><div class="line">);  </div><div class="line">insert into course values(&apos;K1&apos;,&apos;C语言&apos;,&apos;王华&apos;);  </div><div class="line">insert into course values(&apos;K5&apos;,&apos;数据库原理&apos;,&apos;程军&apos;);  </div><div class="line">insert into course values(&apos;K8&apos;,&apos;编译原理&apos;,&apos;程军&apos;);  </div><div class="line">  </div><div class="line">create table sc  </div><div class="line">(  </div><div class="line">    SNO varchar(20) NOT NULL,  </div><div class="line">    CNO varchar(20) NOT NULL,  </div><div class="line">    SCORE int NOT NULL,  </div><div class="line">    primary key (SNO,CNO),  </div><div class="line">    foreign key (SNO) references student(SNO),  </div><div class="line">    foreign key (CNO) references course(CNO)  </div><div class="line">);  </div><div class="line">insert into sc values(&apos;1&apos;,&apos;K1&apos;,83);  </div><div class="line">insert into sc values(&apos;2&apos;,&apos;K1&apos;,85);  </div><div class="line">insert into sc values(&apos;5&apos;,&apos;K1&apos;,92);  </div><div class="line">insert into sc values(&apos;2&apos;,&apos;K5&apos;,90);  </div><div class="line">insert into sc values(&apos;5&apos;,&apos;K5&apos;,84);  </div><div class="line">insert into sc values(&apos;5&apos;,&apos;K8&apos;,80);</div></pre></td></tr></table></figure>
<h2 id="对基本的SQL语句编写的练习题，其中的题目的答案可能会有多种书写方式。"><a href="#对基本的SQL语句编写的练习题，其中的题目的答案可能会有多种书写方式。" class="headerlink" title="对基本的SQL语句编写的练习题，其中的题目的答案可能会有多种书写方式。"></a>对基本的SQL语句编写的练习题，其中的题目的答案可能会有多种书写方式。</h2><ul>
<li>查询“李强”同学所有课程的成绩；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT score FROM sc</div><div class="line">WHERE SNO = </div><div class="line">( SELECT SNO FROM student WHERE SNAME=&quot;李强&quot;</div><div class="line"></div><div class="line">)</div><div class="line"></div><div class="line">//优化：</div><div class="line">SELECT s.SNAME,sc.SCORE FROM student s, sc </div><div class="line">WHERE s.SNO=sc.SNO AND s.SNAME=&quot;李强&quot;</div></pre></td></tr></table></figure>
<ul>
<li>查询课程名为“C语言”的平均成绩；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT AVG(score) FROM sc,course c WHERE sc.CNO=c.CNO AND c.CNAME=&quot;C语言&quot;</div></pre></td></tr></table></figure>
<ul>
<li>检索至少选修王老师所授课程中一门课程的女学生姓名。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT SNAME FROM student</div><div class="line">WHERE SEX=&quot;女&quot; AND SNO in</div><div class="line">( SELECT DISTINCT SNO FROM sc,course c WHERE sc.CNO=c.CNO AND c.teacher LIKE &quot;王%&quot;</div><div class="line">)</div></pre></td></tr></table></figure>
<ul>
<li>检索选修课程包含王老师所授课的学生学号。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT s.SNO FROM student s</div><div class="line">WHERE s.SNO IN</div><div class="line">( SELECT sc.SNO FROM sc,course c</div><div class="line">	WHERE sc.CNO=c.CNO AND c.TEACHER LIKE &quot;王%&quot;</div><div class="line">)</div><div class="line"></div><div class="line">//优化</div><div class="line">SELECT DISTINCT sno FROM sc  </div><div class="line">WHERE cno IN  </div><div class="line">(  </div><div class="line">    SELECT cno FROM course  </div><div class="line">    WHERE teacher LIKE &apos;王%&apos;  </div><div class="line">);</div></pre></td></tr></table></figure>
<ul>
<li>统计有学生选修的课程门数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT count(c.CNO) FROM course c</div><div class="line">WHERE c.CNO IN</div><div class="line">( SELECT DISTINCT sc.CNO FROM sc</div><div class="line">)</div><div class="line"></div><div class="line">//优化</div><div class="line">SELECT count(*)  NumberOfCourse  </div><div class="line">FROM   </div><div class="line">(  </div><div class="line">      SELECT DISTINCT cno FROM sc  </div><div class="line">      GROUP BY cno  </div><div class="line">) AS testTab;</div></pre></td></tr></table></figure>
<hr>
<ul>
<li>检索姓名为两个字，且姓张的学生的姓名和年龄。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT s.SNAME,s.AGE FROM student s WHERE s.SNAME LIKE &quot;张_&quot;</div></pre></td></tr></table></figure>
<ul>
<li>在SC中检索成绩为空值的学生学号和课程号。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT sno,cno FROM sc WHERE score IS NULL;</div></pre></td></tr></table></figure>
<hr>
<h3 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h3><ul>
<li>检索至少选修程老师所授课程中两门课程的女学生姓名。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT s.SNAME FROM student s</div><div class="line">WHERE s.SEX=&quot;女&quot; AND s.SNO IN</div><div class="line">( SELECT sc.SNO FROM sc,course c WHERE sc.CNO=c.CNO AND c.TEACHER LIKE &quot;程%&quot;</div><div class="line">GROUP BY sc.CNO</div><div class="line">HAVING COUNT(sc.CNO)&gt;1</div><div class="line">)</div></pre></td></tr></table></figure>
<ul>
<li>检索选修不少于3门课程的学生学号(SNO)；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT SNO FROM sc</div><div class="line">GROUP BY SNO</div><div class="line">HAVING COUNT(CNO)&gt;=3</div></pre></td></tr></table></figure>
<ul>
<li>检索至少选修两门课程的学生学号。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT sc.SNO FROM sc </div><div class="line">GROUP BY sc.CNO</div><div class="line">HAVING COUNT(sc.CNO)&gt;=2</div></pre></td></tr></table></figure>
<ul>
<li>检索全部学生都选修的课程的课程号与课程名。**</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT c.CNO,c.CNAME FROM course c</div><div class="line">WHERE c.CNO =</div><div class="line">( SELECT sc.CNO FROM sc</div><div class="line">	GROUP BY sc.CNO</div><div class="line">	HAVING COUNT(sc.SNO)=(SELECT COUNT(s.SNO) FROM student s)</div><div class="line">)</div></pre></td></tr></table></figure>
<hr>
<h3 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h3><ul>
<li>求选修K1课程的学生的平均年龄。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT avg(s.AGE) FROM student s,sc</div><div class="line">WHERE s.SNO=sc.SNO AND sc.CNO=&quot;K1&quot;</div><div class="line">//优化</div><div class="line">SELECT AVG(age) AverageOfAge  </div><div class="line">FROM student   </div><div class="line">WHERE sno IN  </div><div class="line">(  </div><div class="line">    SELECT sno FROM sc  </div><div class="line">    WHERE cno=&apos;K1&apos;  </div><div class="line">);</div></pre></td></tr></table></figure>
<ul>
<li>检索李同学不学的课程的课程号。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT c.CNO FROM course c</div><div class="line">WHERE c.CNO NOT IN</div><div class="line">( SELECT sc.CNO FROM sc,student s WHERE sc.SNO=s.SNO AND s.SNAME LIKE &quot;李%&quot;</div><div class="line">)</div></pre></td></tr></table></figure>
<ul>
<li>检索＂李强＂同学不学课程的课程号(CNO)；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">select course.cno from course  </div><div class="line">where course.cno not in  </div><div class="line">(  </div><div class="line">select sc.cno from sc,student  </div><div class="line">where student.sname=&apos;李强&apos; and student.sno=sc.sno  </div><div class="line">);  </div><div class="line"></div><div class="line">//优化：</div><div class="line">SELECT CNO FROM course</div><div class="line">WHERE EXISTS</div><div class="line">( SELECT * FROM student WHERE SNAME=&quot;李强&quot; AND NOT EXISTS</div><div class="line">	( SELECT * FROM sc WHERE sc.CNO=course.CNO	AND sc.SNO=student.SNO</div><div class="line">	)</div><div class="line">)</div></pre></td></tr></table></figure>
<ul>
<li>求程老师所授课程的每门课程的学生平均成绩。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT sc.cno,AVG(sc.score)  </div><div class="line">FROM sc  </div><div class="line">WHERE sc.cno IN  </div><div class="line">(  </div><div class="line">SELECT course.cno FROM course  </div><div class="line">WHERE course.teacher LIKE &apos;程%&apos;  </div><div class="line">)  </div><div class="line">GROUP BY sc.cno  </div><div class="line"></div><div class="line">//优化</div><div class="line">SELECT c.CNAME,avg(sc.SCORE) FROM sc,course c</div><div class="line"></div><div class="line">WHERE sc.CNO=c.CNO AND c.TEACHER LIKE &quot;程%&quot;</div><div class="line"></div><div class="line">GROUP BY sc.CNO</div></pre></td></tr></table></figure>
<hr>
<h3 id="关于-EXISTS和NOT-EXISTS-http-blog-csdn-net-qsyzb-article-details-12523051"><a href="#关于-EXISTS和NOT-EXISTS-http-blog-csdn-net-qsyzb-article-details-12523051" class="headerlink" title="关于 EXISTS和NOT EXISTS:http://blog.csdn.net/qsyzb/article/details/12523051"></a>关于 EXISTS和NOT EXISTS:<a href="http://blog.csdn.net/qsyzb/article/details/12523051" target="_blank" rel="external">http://blog.csdn.net/qsyzb/article/details/12523051</a></h3><ul>
<li>检索至少选修＂程军＂老师所授全部课程的学生姓名（SNAME）<br>（或：检索选修了“程军”老师所授全部课程的学生姓名）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT sname FROM student</div><div class="line">WHERE NOT EXISTS</div><div class="line">( SELECT * FROM course WHERE TEACHER=&quot;程军&quot; AND NOT EXISTS</div><div class="line">	( SELECT * FROM sc WHERE sc.CNO=course.CNO	AND sc.SNO=student.SNO</div><div class="line">	)</div><div class="line">)</div></pre></td></tr></table></figure>
<ul>
<li>检索选修全部课程的学生姓名(SNAME)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT SNAME FROM student</div><div class="line">WHERE NOT EXISTS</div><div class="line">( SELECT * FROM course WHERE NOT EXISTS</div><div class="line">	( SELECT * FROM sc WHERE sc.SNO=student.SNO AND sc.CNO=course.CNO</div><div class="line">	)</div><div class="line">)</div></pre></td></tr></table></figure>
<ul>
<li>检索不学”C语言”的学生信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT * FROM student  </div><div class="line">WHERE EXISTS</div><div class="line">( SELECT * FROM course WHERE cname=&quot;C语言&quot; AND NOT EXISTS</div><div class="line">	( SELECT * FROM sc WHERE sc.CNO=course.CNO AND sc.SNO=student.SNO</div><div class="line">	)</div><div class="line">)</div></pre></td></tr></table></figure>
<hr>
<h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><ul>
<li>统计每门课程的学生选修人数（超过2人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT cno,COUNT(SNO) AS num FROM sc </div><div class="line">GROUP BY cno</div><div class="line">HAVING COUNT(sno)&gt;=2</div><div class="line">ORDER BY num DESC, cno ASC</div><div class="line"></div><div class="line">//优化</div><div class="line">SELECT cno,Num  </div><div class="line">FROM   </div><div class="line">(  </div><div class="line">SELECT cno,count(*) as Num  </div><div class="line">FROM sc  </div><div class="line">GROUP BY cno HAVING (count(*) &gt;= 2)  </div><div class="line">) tb_temp  </div><div class="line">ORDER BY Num DESC,cno ASC</div></pre></td></tr></table></figure>
<ul>
<li>检索学号比李同学大，而年龄比他小的学生姓名。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT s.sname </div><div class="line">FROM student s,(SELECT MAX(sno) snoLi,MIN(age) ageLi FROM student WHERE sname LIKE &quot;李%&quot;) AS stuLi</div><div class="line">WHERE s.sno&gt;stuLi.snoLi AND s.age&lt;stuLi.ageLi</div></pre></td></tr></table></figure>
<ul>
<li>求年龄大于女同学平均年龄的男学生姓名和年龄。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT s.SNAME,s.AGE FROM student s,(SELECT AVG(age) avgAge FROM student WHERE SEX=&quot;女&quot;) AS FeStu</div><div class="line"> WHERE s.AGE&gt;FeStu.avgAge</div><div class="line"></div><div class="line">//优化</div><div class="line">SELECT sname,age FROM student  </div><div class="line">WHERE  </div><div class="line">sex=&apos;男&apos; AND age &gt; (  </div><div class="line">                      SELECT AVG(age)  </div><div class="line">                      FROM student  </div><div class="line">                      WHERE sex=&apos;女&apos;  </div><div class="line">                   )  </div><div class="line">;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/wolfofsiberian/article/details/39346781&quot;&gt;http://blog.csdn.net/wolfofsiberian/article/details/39346781&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SQL总结（一）基本查询：&lt;a href=&quot;http://www.imooc.com/article/1412&quot;&gt;http://www.imooc.com/article/1412&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://nibnait.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="MySQL" scheme="http://nibnait.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Nexus6拆机换电池</title>
    <link href="http://nibnait.com/9cc2e03e-Nexus6-Disassemble-replace-the-battery/"/>
    <id>http://nibnait.com/9cc2e03e-Nexus6-Disassemble-replace-the-battery/</id>
    <published>2016-07-14T09:40:06.000Z</published>
    <updated>2016-07-20T15:14:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>准备工作： 关机、拿出SIM卡</p>
<a id="more"></a>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/9cc2e03e-1.jpg" alt=""></p>
<p>最难做的就是这第一步：拆后盖。</p>
<p>由于Nexus是一体机，原则上：不可更换电池。所以他的后盖上吗一定会用双面胶之类的东西，将后盖粘死。</p>
<p>所以，我刚开始 不管怎么翘那一个小角，淘宝赠送的那个小三角块 刃敲劈了，也毫无反应。</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/9cc2e03e-2.jpg" alt=""></p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/9cc2e03e-3.jpg" alt=""></p>
<p>正当我准备把这220块的Dbrand贴纸给废了，一点点撕下来的时候，咦，中间有希望被撬开啊。赶紧拿镊子别住，一点点，这个后盖是软塑料做的，随便掰 不要怕。 好了 下一步：卸螺丝，拆中框</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/9cc2e03e-4.jpg" alt="后盖上什么也没有"></p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/9cc2e03e-5.jpg" alt="螺丝真不少"></p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/9cc2e03e-6.jpg" alt="左屏幕+主板，右中框+电池"></p>
<p>由于电池和中框之间有双面胶，所以不建议强拆，可以拿吹风机，先吹一吹，再试试。</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/9cc2e03e-7.png" alt="全家福"></p>
<p>最后 我还是粘了两道双面胶。<br><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/9cc2e03e-8.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;准备工作： 关机、拿出SIM卡&lt;/p&gt;
    
    </summary>
    
      <category term="瞎折腾" scheme="http://nibnait.com/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="刷机" scheme="http://nibnait.com/tags/%E5%88%B7%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>路由器刷机</title>
    <link href="http://nibnait.com/53e45808-K2-router-Brush/"/>
    <id>http://nibnait.com/53e45808-K2-router-Brush/</id>
    <published>2016-07-07T08:10:22.000Z</published>
    <updated>2016-07-14T02:49:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>前两天，经朋友推荐，买了个斐讯K2路由器。</p>
<p>为啥没事买个路由器？</p>
<p>因为：<a href="http://www.lianbijr.com/webhtml/4374.html" target="_blank" rel="external">http://www.lianbijr.com/webhtml/4374.html</a><br>相当于￥399买个路由器，送你￥419理财金（一个月之后可以直接体现走人）。这种好事 为啥不干。</p>
<a id="more"></a>
<p>K2路由器采用联发科MTK集成芯片，这是国内所谓智能路由器厂商，包括极路由器、小米路由器都在使用的廉价芯片方案，好处是耐折腾。</p>
<p><a href="http://jingyan.baidu.com/article/fedf073772e73535ac8977a6.html" target="_blank" rel="external">MTK7620A</a>芯片介绍资料，堪称刷机王。</p>
<p>好了，路由器到手了，开始折腾</p>
<p>参考资料：</p>
<ul>
<li><a href="http://tieba.baidu.com/p/44880743620" target="_blank" rel="external">http://tieba.baidu.com/p/4488074362</a></li>
<li><a href="http://www.886abc.com/2568.html" target="_blank" rel="external">http://www.886abc.com/2568.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天，经朋友推荐，买了个斐讯K2路由器。&lt;/p&gt;
&lt;p&gt;为啥没事买个路由器？&lt;/p&gt;
&lt;p&gt;因为：&lt;a href=&quot;http://www.lianbijr.com/webhtml/4374.html&quot;&gt;http://www.lianbijr.com/webhtml/4374.html&lt;/a&gt;&lt;br&gt;相当于￥399买个路由器，送你￥419理财金（一个月之后可以直接体现走人）。这种好事 为啥不干。&lt;/p&gt;
    
    </summary>
    
      <category term="瞎折腾" scheme="http://nibnait.com/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="刷机" scheme="http://nibnait.com/tags/%E5%88%B7%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>你多久没有清理你的机械键盘了？</title>
    <link href="http://nibnait.com/3a8b9a20-cleanup-my-keyboard/"/>
    <id>http://nibnait.com/3a8b9a20-cleanup-my-keyboard/</id>
    <published>2016-07-06T03:51:17.000Z</published>
    <updated>2016-07-07T08:20:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚考完试，闲来无事，发现机械键盘键帽上有好多灰，清理一下吧。</p>
<p>下面上图（倒叙，最后一张图 很劲爆 请最好心理准备）</p>
<a id="more"></a>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/3a8b9a20-1.jpg" alt="清理完毕图"></p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/3a8b9a20-2.jpg" alt="清理完毕图2"></p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/3a8b9a20-3.jpg" alt="拆下来的键帽"></p>
<p>。</p>
<p>。</p>
<p>。</p>
<p>前</p>
<p>。</p>
<p>。</p>
<p>方</p>
<p>。</p>
<p>。</p>
<p>。</p>
<p>高</p>
<p>。</p>
<p>。</p>
<p>能</p>
<p>。</p>
<p>。</p>
<p>。</p>
<p>。</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/3a8b9a20-4.jpg" alt="各种食物残渣"></p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/3a8b9a20-5.jpg" alt=""></p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/3a8b9a20-6.jpg" alt="细节图"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚考完试，闲来无事，发现机械键盘键帽上有好多灰，清理一下吧。&lt;/p&gt;
&lt;p&gt;下面上图（倒叙，最后一张图 很劲爆 请最好心理准备）&lt;/p&gt;
    
    </summary>
    
      <category term="瞎折腾" scheme="http://nibnait.com/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>Nexus6 刷Android6.0</title>
    <link href="http://nibnait.com/55904a6f-Nexus6-Brush-Android6.0/"/>
    <id>http://nibnait.com/55904a6f-Nexus6-Brush-Android6.0/</id>
    <published>2016-07-02T05:26:17.000Z</published>
    <updated>2016-07-14T02:50:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：</p>
<ul>
<li>配置ADB环境：<a href="http://www.25pp.com/news/news_76805.html" target="_blank" rel="external">http://www.25pp.com/news/news_76805.html</a></li>
<li>刷机教程：<a href="http://www.jianshu.com/p/280bb98e4f15#" target="_blank" rel="external">http://www.jianshu.com/p/280bb98e4f15#</a></li>
</ul>
<a id="more"></a>
<ul>
<li>Nexus系列官方刷机包：<a href="https://developers.google.com/android/nexus/images" target="_blank" rel="external">https://developers.google.com/android/nexus/images</a></li>
<li>我的adb：<a href="http://7xr7ju.com1.z0.glb.clouddn.com/download/adb.rar" target="_blank" rel="external">点击直接下载 3.50M</a></li>
</ul>
<h1 id="一、-配置adb环境变量并下载"><a href="#一、-配置adb环境变量并下载" class="headerlink" title="一、 配置adb环境变量并下载"></a>一、 配置adb环境变量并下载</h1><p>解压 adb.rar，将adb的文件夹路径放入path中</p>
<p>我下的是这个包：<a href="https://dl.google.com/dl/android/aosp/angler-mmb29m-factory-8c31db3f.tgz" target="_blank" rel="external">6.0.1 (MMB29M) 1.01G</a></p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/55904a6f-1.png" alt="下载好的刷机包解压后文件"></p>
<h1 id="二、-按住电源键和音量减进入Bootloader模式"><a href="#二、-按住电源键和音量减进入Bootloader模式" class="headerlink" title="二、 按住电源键和音量减进入Bootloader模式"></a>二、 按住电源键和音量减进入Bootloader模式</h1><p>在adb环境下 依次输入</p>
<ul>
<li>fastboot flash bootloader bootloader-×××.img</li>
<li>fastboot flash radio radio-×××.img</li>
</ul>
<p>然后重启：</p>
<ul>
<li>fastboot reboot-bootloader</li>
</ul>
<p>然后依次刷入recovery、boot、system等</p>
<ul>
<li>fastboot flash recovery recovery.img</li>
<li>fastboot flash boot boot.img</li>
<li>fastboot flash system system.img</li>
</ul>
<p>以上步骤完成后还需要清除掉旧的数据：</p>
<ul>
<li>fastboot flash cache cache.img</li>
<li>fastboot flash userdata userdata.img</li>
<li>全部结束后输入命令重启手机： ：fastboot reboot</li>
</ul>
<blockquote>
<p>注意：<br>1、以上着重标记的img文件是你已经下载好解压出来的镜像文件，在执行命令的时候请带上完整的文件路径。<br>2、 在第一次启动后，很多人会卡在正在检测网络连接中，因为自己的Wi-Fi和手机移动网络没办法翻墙。遇到这个问题可以找一个带有VPN的Wi-Fi热点，或者把手机卡拔出，不要连Wi-Fi即可暂时跳过此步骤。</p>
</blockquote>
<p>刷机有风险，root需谨慎<br>相关链接：</p>
<ul>
<li><a href="http://maybeiwill.me/location-report-enabler/" target="_blank" rel="external">http://maybeiwill.me/location-report-enabler/</a>  </li>
<li><a href="启用位置报告LocationReportEnabler">启用位置报告LocationReportEnabler</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置ADB环境：&lt;a href=&quot;http://www.25pp.com/news/news_76805.html&quot;&gt;http://www.25pp.com/news/news_76805.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;刷机教程：&lt;a href=&quot;http://www.jianshu.com/p/280bb98e4f15#&quot;&gt;http://www.jianshu.com/p/280bb98e4f15#&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="瞎折腾" scheme="http://nibnait.com/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="刷机" scheme="http://nibnait.com/tags/%E5%88%B7%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【转】Spring 的本质系列(2) -- AOP</title>
    <link href="http://nibnait.com/f367b0a2-Spring--AOP/"/>
    <id>http://nibnait.com/f367b0a2-Spring--AOP/</id>
    <published>2016-06-30T14:20:02.000Z</published>
    <updated>2016-06-30T15:17:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513187&amp;idx=1&amp;sn=f603eee3e798e79ce010c9d58cd2ecf3&amp;scene=0&amp;pass_ticket=FoMQ%2Bi0rJ1U6SA778stF%2F5H7gGDciXgk%2FXasW6rmTCq3NhjU2wZ1oTNtXuAAAzWi#rd" target="_blank" rel="external">https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513187&amp;idx=1&amp;sn=f603eee3e798e79ce010c9d58cd2ecf3&amp;scene=0&amp;pass_ticket=FoMQ%2Bi0rJ1U6SA778stF%2F5H7gGDciXgk%2FXasW6rmTCq3NhjU2wZ1oTNtXuAAAzWi#rd</a></p>
</blockquote>
<a id="more"></a>
<p>AOP（Aspect Oriented Programming）就是面向切面的编程， 为什么是面向切面， 而不是面向对象呢？</p>
<h1 id="1-问题来源"><a href="#1-问题来源" class="headerlink" title="1. 问题来源"></a>1. 问题来源</h1><p>我们在做系统设计的时候，一个非常重要的工作就是把一个大系统做分解， 按业务功能分解成一个个低耦合、高内聚的模块，就像这样：</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/f367b0a2-1.png" alt=""></p>
<p>但是分解以后就会发现有些很有趣的东西， 这些东西是通用的，或者是跨越多个模块的：</p>
<p><strong>日志</strong>： 对特定的操作输出日志来记录<br><strong>安全</strong>：在执行操作之前进行操作检查<br><strong>性能</strong>：要统计每个方法的执行时间<br><strong>事务</strong>：方法开始之前要开始事务， 结束后要提交或者回滚事务<br>等等….</p>
<p>这些可以称为是非功能需求， 但他们是多个业务模块都需要的， 是跨越模块的， 把他们放到什么地方呢？</p>
<p>最简单的办法就是把这些通用模块的接口写好， 让程序员在实现业务模块的时候去调用就可以了，码农嘛，辛苦一下也没什么。</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/f367b0a2-2.png" alt=""></p>
<p>这样做看起来没问题， 只是会产生类似这样的代码：</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/f367b0a2-3.png" alt=""></p>
<p>这样的代码也实现了功能，但是看起来非常的不爽， 那就是日志，性能，事务 相关的代码几乎要把真正的业务代码给淹没了。</p>
<p>不仅仅这一个类需要这么干， 其他类都得这么干， 重复代码会非常的多。</p>
<p>有经验的程序员还好， 新手忘记写这样的非业务代码简直是必然的。</p>
<h1 id="2-设计模式：模板方法"><a href="#2-设计模式：模板方法" class="headerlink" title="2. 设计模式：模板方法"></a>2. 设计模式：模板方法</h1><p>用设计模式在某些情况下可以部分解决上面的问题，例如著名的<strong>模板方法</strong>：</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/f367b0a2-4.png" alt=""></p>
<p>在<strong>父类（BaseCommand）中已经把那些“乱七八糟“的非功能代码都写好了， 只是留了一个口子（抽象方法doBusiness()）让子类去实现。</strong></p>
<p>子类变的清爽， 只需要关注业务逻辑就可以了。<br>调用也很简单，例如：  </p>
<blockquote>
<p>BaseCommand  cmd = …  获得PlaceOrderCommand的实例…<br>cmd.execute();</p>
</blockquote>
<p>但是这样方式的巨大缺陷就是父类会定义一切： <strong>要执行哪些非功能代码， 以什么顺序执行等等<br>子类只能无条件接受，完全没有反抗余地。</strong></p>
<p>如果有个子类， 根本不需要事务， 但是它也没有办法把事务代码去掉。</p>
<h1 id="3-设计模式：装饰者"><a href="#3-设计模式：装饰者" class="headerlink" title="3. 设计模式：装饰者"></a>3. 设计模式：装饰者</h1><p>如果利用装饰者模式， 针对上面的问题，可以带来更大的灵活性：</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/f367b0a2-5.png" alt=""></p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/f367b0a2-6.png" alt=""></p>
<p>现在让这个PlaceOrderCommand 能够打印日志，进行性能统计</p>
<blockquote>
<p>Command cmd = new <strong>LoggerDecorator</strong>(<br><span style="opacity:0">asdfas</span>new <strong>PerformanceDecorator</strong>(<br><span style="opacity:0">asdfasdf</span>new <strong>PlaceOrderCommand</strong>()));<br>cmd.execute();</p>
</blockquote>
<p>如果PaymentCommand 只需要打印日志，装饰一次就可以了：</p>
<blockquote>
<p>Command cmd = new <strong>LoggerDecorator</strong>(<br><span style="opacity:0">asdfas</span>new <strong>PaymentCommand</strong>());<br>cmd.execute();</p>
</blockquote>
<p>可以使用任意数量装饰器，还可以以任意次序执行（严格意义上来说是不行的）， 是不是很灵活？ </p>
<h1 id="4-AOP"><a href="#4-AOP" class="headerlink" title="4. AOP"></a>4. AOP</h1><p>如果仔细思考一下就会发现装饰者模式的不爽之处:<br>(1)  一个处理日志/性能/事务 的类为什么要实现 业务接口（Command）呢?<br>(2) 如果别的业务模块，没有实现Command接口，但是也想利用日志/性能/事务等功能，该怎么办呢？</p>
<p><strong>最好把日志/安全/事务这样的代码和业务代码完全隔离开来，因为他们的关注点和业务代码的关注点完全不同</strong> ，他们之间应该是正交的，他们之间的关系<br>应该是这样的：</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/f367b0a2-7.png" alt=""></p>
<p>如果把这个业务功能看成一层层面包的话， 这些日志/安全/事务 像不像一个个“切面”(Aspect) ？</p>
<p>如果我们能让这些“切面“能和业务独立，  并且能够非常灵活的“织入”到业务方法中， 那就实现了面向切面编程(AOP)！</p>
<h1 id="5-实现AOP"><a href="#5-实现AOP" class="headerlink" title="5. 实现AOP"></a>5. 实现AOP</h1><p>现在我们来实现AOP吧， 首先我们得有一个所谓的“切面“类(Aspect)， 这应该是一个普通的java 类 ， 不用实现什么“乱七八糟”的接口。<br>以一个事务类为例：</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/f367b0a2-8.png" alt=""></p>
<p>我们想达到的目的只这样的： 对于com.coderising这个包中所有类的execute方法， 在方法调用之前，需要执行Transaction.beginTx()方法， 在调用之后， 需要执行Transaction.commitTx()方法。</p>
<p>暂时停下脚步分析一下。</p>
<ul>
<li><p>“对于com.coderising这个包中所有类的execute方法” ， 用一个时髦的词来描述就是<strong>切入点（PointCut）</strong> , 它可以是一个方法或一组方法（可以通过通配符来支持，你懂的）</p>
</li>
<li><p>“在方法调用之前/之后 ， 需要执行xxx” , 用另外一个时髦的词来描述就是<strong>通知（Advice）</strong></p>
</li>
</ul>
<p>码农翻身认为，PointCut,Advice 这些词实在是不直观， 其实Spring的作者们也是这么想的 :  </p>
<blockquote>
<p>These terms are not Spring-specific… unfortunately, AOP terminology is not particularly intuitive; however, it would be even more confusing if Spring used its own terminology.</p>
</blockquote>
<p>当然，想描述这些规则， xml依然是不二之选：</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/f367b0a2-9.png" alt=""></p>
<p>注意：现在<strong>Transaction这个类和业务类在源代码层次上没有一点关系，完全隔离了。</strong></p>
<p>隔离是一件好事情， 但是马上给我们带来了大麻烦 。</p>
<p>Java 是一门静态的强类型语言， 代码一旦写好， 编译成java class 以后 ，可以在运行时通过反射（Reflection）来查看类的信息， 但是想对类进行修改非常困难。 </p>
<p>而AOP要求的恰恰就是在不改变业务类的源代码（其实大部分情况下你也拿不到）的情况下， 修改业务类的方法, 进行功能的增强，就像上面给所有的业务类增加事务支持。</p>
<p>为了突破这个限制，大家可以说是费尽心机， 现在基本是有这么几种技术：</p>
<p>(1) 在编译的时候， 根据<strong>AOP的配置</strong>信息，悄悄的把日志，安全，事务等“切面”代码 和业务类编译到一起去。</p>
<p>(2) 在运行期，业务类加载以后， 通过<strong>Java动态代理技术</strong>为业务类生产一个代理类， 把“切面”代码放到代理类中，  Java 动态代理要求业务类需要实现接口才行。</p>
<p>(3) 在运行期， 业务类加载以后， 动态的使用字节码构建一个业务类的子类，将“切面”逻辑加入到子类当中去, <strong>CGLIB</strong>就是这么做的。</p>
<p>Spring采用的就是(2) +(3) 的方式，限于篇幅，这里不再展开各种技术了， 不管使用哪一种方式， 在运行时，真正干活的“业务类”其实已经不是原来单纯的业务类了， 它们被AOP了 ！</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/coderising.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;amp;mid=2665513187&amp;amp;idx=1&amp;amp;sn=f603eee3e798e79ce010c9d58cd2ecf3&amp;amp;scene=0&amp;amp;pass_ticket=FoMQ%2Bi0rJ1U6SA778stF%2F5H7gGDciXgk%2FXasW6rmTCq3NhjU2wZ1oTNtXuAAAzWi#rd&quot;&gt;https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;amp;mid=2665513187&amp;amp;idx=1&amp;amp;sn=f603eee3e798e79ce010c9d58cd2ecf3&amp;amp;scene=0&amp;amp;pass_ticket=FoMQ%2Bi0rJ1U6SA778stF%2F5H7gGDciXgk%2FXasW6rmTCq3NhjU2wZ1oTNtXuAAAzWi#rd&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="刘欣-码农翻身" scheme="http://nibnait.com/categories/%E5%88%98%E6%AC%A3-%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB/"/>
    
    
      <category term="转载" scheme="http://nibnait.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="Java番外篇" scheme="http://nibnait.com/tags/Java%E7%95%AA%E5%A4%96%E7%AF%87/"/>
    
      <category term="Spring" scheme="http://nibnait.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>一些常用的下载地址</title>
    <link href="http://nibnait.com/429f9872-common-download-addresses/"/>
    <id>http://nibnait.com/429f9872-common-download-addresses/</id>
    <published>2016-06-29T02:10:04.000Z</published>
    <updated>2016-08-01T09:40:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h1><ul>
<li>JDK 1.8：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></li>
<li>JDK 1.7：<a href="http://www.oracle.com/technetwork/cn/java/javase/downloads/jdk7-downloads-1880260.html" target="_blank" rel="external">http://www.oracle.com/technetwork/cn/java/javase/downloads/jdk7-downloads-1880260.html</a></li>
<li>JDK 1.6：    <a href="http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase6-419409.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase6-419409.html</a></li>
<li>JDK 1.5：<a href="http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-javase5-419410.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-javase5-419410.html</a></li>
</ul>
<a id="more"></a>
<h1 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h1><p><a href="https://www.google.com/chrome/" target="_blank" rel="external">https://www.google.com/chrome/</a></p>
<h1 id="Windows镜像"><a href="#Windows镜像" class="headerlink" title="Windows镜像"></a>Windows镜像</h1><p><a href="http://msdn.itellyou.cn/" target="_blank" rel="external">http://msdn.itellyou.cn/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JDK&quot;&gt;&lt;a href=&quot;#JDK&quot; class=&quot;headerlink&quot; title=&quot;JDK&quot;&gt;&lt;/a&gt;JDK&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;JDK 1.8：&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&quot;&gt;http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;JDK 1.7：&lt;a href=&quot;http://www.oracle.com/technetwork/cn/java/javase/downloads/jdk7-downloads-1880260.html&quot;&gt;http://www.oracle.com/technetwork/cn/java/javase/downloads/jdk7-downloads-1880260.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;JDK 1.6：    &lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase6-419409.html&quot;&gt;http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase6-419409.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;JDK 1.5：&lt;a href=&quot;http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-javase5-419410.html&quot;&gt;http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-javase5-419410.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="瞎推荐" scheme="http://nibnait.com/categories/%E7%9E%8E%E6%8E%A8%E8%8D%90/"/>
    
    
  </entry>
  
  <entry>
    <title>【转】Spring 的本质系列(1) -- 依赖注入</title>
    <link href="http://nibnait.com/c1b0daa6-Spring--Dependency-Injection/"/>
    <id>http://nibnait.com/c1b0daa6-Spring--Dependency-Injection/</id>
    <published>2016-06-25T14:54:04.000Z</published>
    <updated>2016-06-27T12:54:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513179&amp;idx=1&amp;sn=772226a5be436a0d08197c335ddb52b8&amp;scene=0&amp;pass_ticket=hetuWo8pXY0relnuIcQXVKZFV9FWXXUvWFf%2Fcrr3OYUPLy%2FU0hVJ6NYIR6wCsIFV" target="_blank" rel="external">https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513179&amp;idx=1&amp;sn=772226a5be436a0d08197c335ddb52b8&amp;scene=0&amp;pass_ticket=hetuWo8pXY0relnuIcQXVKZFV9FWXXUvWFf%2Fcrr3OYUPLy%2FU0hVJ6NYIR6wCsIFV</a></p>
</blockquote>
<p>相关阅读：<a href="http://www.importnew.com/14751.html" target="_blank" rel="external">Spring的IOC原理</a></p>
<a id="more"></a>
<h1 id="1-对象的创建"><a href="#1-对象的创建" class="headerlink" title="1. 对象的创建"></a>1. 对象的创建</h1><p>面向对象的编程语言是用类(Class)来对现实世界进行抽象， 在运行时这些类会生成对象(Object)。 </p>
<p>当然，单独的一个或几个对象根本没办法完成复杂的业务， 实际的系统是由千千万万个对象组成的， 这些对象需要互相协作才能干活，例如对象A调用对象B的方法，那必然会提出一个问题：对象A怎么才能获得对象B的引用呢？</p>
<p>最简单的办法无非是： 当对象A需要使用对象B的时候， <strong>把它给new 出来</strong> ，这也是最常用的办法， java 不就是这么做的？例如：  </p>
<p>Apple a = new Apple();</p>
<p>后来业务变复杂了， 抽象出了一个水果(Fruit)的类， 创建对象会变成这个样子：</p>
<p>Fruit f1 = new Apple();<br>Fruit f2 = new Banana();<br>Fruit f3 = ……</p>
<p>很自然的，类似下面的代码就会出现：<br><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/c1b0daa6-1.png" alt=""></p>
<p>这样的代码如果散落在各处，维护起来将会痛苦不堪， 例如你新加一个水果的类型Orange, 那得找到系统中所有的这些创建Fruit的地方，进行修改， 这绝对是一场噩梦。</p>
<p>解决办法也很简单， 前辈们早就总结好了：<a href="http://nibnait.com/7d37b1c4-Factory-Pattern/">工厂模式</a></p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/c1b0daa6-2.png" alt=""></p>
<p>工厂模式，以及其他模式像抽象工厂， Builder模式提供的都是创建对象的方法。</p>
<p>这背后体现的都是“<strong>封装变化</strong>”的思想。</p>
<p>这些模式只是一些最佳实践而已： 起了一个名称、描述一下解决的问题、使用的范围和场景，码农们在项目中还得自己去编码实现他们。</p>
<h1 id="2-解除依赖"><a href="#2-解除依赖" class="headerlink" title="2. 解除依赖"></a>2. 解除依赖</h1><p>我们再来看一个稍微复杂一点， 更加贴近实际项目的例子：</p>
<p>一个订单处理类，它会被定时调用：  查询数据库中订单的处理情况， 必要时给下订单的用户发信。</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/c1b0daa6-3.png" alt=""></p>
<p>看起来也没什么难度， 需要注意的是很多类一起协作了， 尤其是OrderProcessor , 它依赖于<br>OrderService 和 EmailService这两个服务，它获取依赖的方式就是通过<strong>单例方法</strong>。</p>
<p>如果你想对这个process方法进行单元测试–<strong>这也是很多优秀的团队要求的</strong>– 麻烦就来了。 </p>
<p>首先OrderService 确实会从真正的数据库中取得Order信息，你需要确保数据库中有数据， 数据库连接没问题，实际上如果数据库连接Container（例如Tomcat）管理的， 你没有Tomcat很难建立数据库连接。</p>
<p>其次这个EmailService 真的会对外发邮件， 你可不想对真正的用户发测试邮件，当然你可以修改数据库，把邮件地址改成假的，但那样很麻烦， 并且EmailService 会抛出一堆错误来，很不爽。</p>
<p>所有的这些障碍， 最终会导致脆弱的单元测试： <strong>速度慢， 不可重复，需要手工干预，不能独立运行。</strong></p>
<p>想克服这些障碍， 一个可行的办法就是不在方法中直接调用OrderService和EmailService的getInstance()方法， 而是把他们通过setter方法传进来。</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/c1b0daa6-4.png" alt=""></p>
<p>通过这种方式，你的单元测试就可以构造一个假的OrderService 和假的EmailService 了。</p>
<p>例如OrderService 的冒牌货可以是MockOrderService , 它可以返回你想要的任何Order 对象， 而不是从数据库取。</p>
<p>MockEmailService 也不会真的发邮件， 而是把代码中试图发的邮件保存下来， 测试程序可以检查是否正确。</p>
<p>你的测试代码可能是这样的：</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/c1b0daa6-5.png" alt=""></p>
<p>当然， 有经验的你马上就会意识到： 需要把OrderService 和 EmailService 变成 接口或者抽象类， 这样才可以把Mock对象传进来。 </p>
<p>这其实也遵循了面向对象编程的另外一个要求： <strong>对接口编程， 而不是对实现编程</strong>。</p>
<h1 id="3-Spring-依赖注入"><a href="#3-Spring-依赖注入" class="headerlink" title="3. Spring 依赖注入"></a>3. Spring 依赖注入</h1><p>啰啰嗦嗦说了这么多， 快要和Spring扯上关系了。</p>
<p>上面的代码其实就是实现了一个依赖的注入，把两个冒牌货注入到业务类中(通过set方法)， 这个注入的过程是在一个测试类中通过代码完成的。</p>
<p>既然能把冒牌货注入进去，  那毫无疑问，肯定也能把一个正经的类安插进去， 因为setter 方法接受的是接口，而不是具体类。</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/c1b0daa6-6.png" alt=""></p>
<p>用这种方式来处理对象之间的依赖， 会强迫你对接口编程， 好处显而易见。 </p>
<p>随着系统复杂度的增长， 这样的代码会越来越多， 最后也会变得难于维护。 </p>
<p>能不能把各个类之间的依赖关系统一维护呢？<br>能不能把系统做的更加灵活一点，用声明的方式而不是用代码的方式来描述依赖关系呢？</p>
<p>肯定可以， 在Java 世界里，如果想描述各种逻辑关系， XML是不二之选：</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/c1b0daa6-7.png" alt=""></p>
<p>公众号“码农翻身”友情提示：我们熟悉的bean 又出现了， 想了解历史的可以看下文章<a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513115&amp;idx=1&amp;sn=da30cf3d3f163d478748fcdf721b6414&amp;scene=21#wechat_redirect" target="_blank" rel="external">《Java帝国之Java bean (上)》</a> 和<a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513118&amp;idx=1&amp;sn=487fefb8fa7efd59de6f37043eb21799&amp;scene=21#wechat_redirect" target="_blank" rel="external">《Java帝国之Java bean (下)》</a></p>
<p>这个xml 挺容易理解的， 但是仅仅有它还不够， 还缺一个解析器（假设叫做XmlAppContext）来解析，处理这个文件，基本过程是：</p>
<ol>
<li><p>解析xml, 获取各种元素</p>
</li>
<li><p>通过<strong>Java反射</strong>把各个bean 的实例创建起来： com.coderising.OrderProcessor   , OrderServiceImpl, EmailServiceImpl. </p>
</li>
<li><p>还是通过<strong>Java反射</strong>调用OrderProcessor的两个方法：setOrderService(….)  和 setEmailService(…) 把orderService , emailService 实例 注入进去。</p>
</li>
</ol>
<p>应用程序使用起来就简单了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">XmlAppContext ctx = new XmlAppContext(&quot;c:\\bean.xml&quot;);</div><div class="line"></div><div class="line">OrderProcessor op = (OrderProcessor) ctx.getBean(&quot;order-processor&quot;);</div><div class="line"></div><div class="line">op.process();</div></pre></td></tr></table></figure>
<p>其实Spring的处理方式和上面说的非常类似， 当然Spring 处理了更多的细节，例如不仅仅是setter方法注入， 还可以构造函数注入，init 方法， destroy方法等等， 基本思想是一致的。</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/c1b0daa6-8.png" alt=""></p>
<p><strong>既然对象的创建过程和装配过程都是Spring做的， 那Spring 在这个过程中就可以玩很多把戏了， 比如对你的业务类做点字节码级别的增强， 搞点AOP什么的， 这都不在话下了。 </strong></p>
<h1 id="4-IoC-vs-DI"><a href="#4-IoC-vs-DI" class="headerlink" title="4. IoC vs DI"></a>4. IoC vs DI</h1><p>“不要给我们打电话，我们会打给你的(don‘t call us, we‘ll call you)”这是著名的好莱坞原则。</p>
<p>在好莱坞，把简历递交给演艺公司后就只有回家等待。由演艺公司对整个娱乐项目完全控制，演员只能被动式的接受公司的差使,在需要的环节中，完成自己的演出。</p>
<p>这和软件开发有一定的相似性， 演员们就像一个个Java Object, 最早的时候自己去创建自己所依赖的对象，   有了演艺公司（Spring容器）的介入，所有的依赖关系都是演艺公司搞定的， 于是控制就翻转了<br>Inversion of Control, 简称IoC。 </p>
<p>但是IoC这个词不能让人更加直观和清晰的理解背后所代表的含义， 于是Martin Flower先生就创造了一个新词 : 依赖注入 (Dependency Injection，简称DI),  是不是更加贴切一点？</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/coderising.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;amp;mid=2665513179&amp;amp;idx=1&amp;amp;sn=772226a5be436a0d08197c335ddb52b8&amp;amp;scene=0&amp;amp;pass_ticket=hetuWo8pXY0relnuIcQXVKZFV9FWXXUvWFf%2Fcrr3OYUPLy%2FU0hVJ6NYIR6wCsIFV&quot;&gt;https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;amp;mid=2665513179&amp;amp;idx=1&amp;amp;sn=772226a5be436a0d08197c335ddb52b8&amp;amp;scene=0&amp;amp;pass_ticket=hetuWo8pXY0relnuIcQXVKZFV9FWXXUvWFf%2Fcrr3OYUPLy%2FU0hVJ6NYIR6wCsIFV&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相关阅读：&lt;a href=&quot;http://www.importnew.com/14751.html&quot;&gt;Spring的IOC原理&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="刘欣-码农翻身" scheme="http://nibnait.com/categories/%E5%88%98%E6%AC%A3-%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB/"/>
    
    
      <category term="转载" scheme="http://nibnait.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="Java番外篇" scheme="http://nibnait.com/tags/Java%E7%95%AA%E5%A4%96%E7%AF%87/"/>
    
      <category term="Spring" scheme="http://nibnait.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>【转】我是一个路由器</title>
    <link href="http://nibnait.com/6d7d656b-im-a-router/"/>
    <id>http://nibnait.com/6d7d656b-im-a-router/</id>
    <published>2016-06-22T17:37:00.000Z</published>
    <updated>2016-06-27T17:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513173&amp;idx=1&amp;sn=6ec5281b12ed5195070fa4df22383595&amp;scene=1&amp;srcid=0627CDacGQUGTDaYwsDaX5WZ&amp;pass_ticket=QrfnD%2BuaEgpuqOnN6%2FGXOi567jtFjIp2BC3s%2FUjmZiv8wSD%2FZ5ZT%2BQLisdjZLtci#rd" target="_blank" rel="external">https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513173&amp;idx=1&amp;sn=6ec5281b12ed5195070fa4df22383595&amp;scene=1&amp;srcid=0627CDacGQUGTDaYwsDaX5WZ&amp;pass_ticket=QrfnD%2BuaEgpuqOnN6%2FGXOi567jtFjIp2BC3s%2FUjmZiv8wSD%2FZ5ZT%2BQLisdjZLtci#rd</a></p>
</blockquote>
<a id="more"></a>
<p>我就是网卡TP-Link 7954经常和大家提起的<strong>网关路由器</strong>，  我在网络中的位置是这样的：</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/6d7d656b-1.png" alt=""></p>
<p>为啥叫网关呢？ 因为大家想上网，一定得经过我这一关  :-)</p>
<p>这不是开玩笑，确实是这样， 所有的对局域网之外的访问那非得经过我不可。</p>
<p>其实我直接和ISP(就是联通！)的网络相连，  我从联通那里搞了一个外网的地址： 61.52.247.112 。</p>
<p>可是只有这么一个地址， 我们局域网内这么多电脑， 如果轮流着让每个电脑去用， 那大家可就抱怨死了。 </p>
<p>于是我巧妙的构思了一个网络世界，  成功的欺骗了TP-Link 7954这些网卡们。</p>
<h1 id="1-NAT-网络地址转换"><a href="#1-NAT-网络地址转换" class="headerlink" title="1. NAT (网络地址转换)"></a>1. NAT (网络地址转换)</h1><p>还记得上次TP-Link 7954 向我要地址的事儿吗 ? </p>
<p>因为我不仅仅是个路由器， 还是一个DHCP服务器， 掌握着这个局域网的IP生杀大权。</p>
<p>我给TP-Link 7954 分配的IP是 192.168.1.2  ， 但是他拿这个地址是无法直接上网的， 因为这是属于我管辖的内网地址， 别的网站像www.baidu.com  根本都不知道！</p>
<p>即使知道了也没用， 因为在这个世界上可能有无数的路由器都会分配192.168.xxx.xxx 这样的地址， 你到底要找哪一个？</p>
<p>所以TP-Link 7954 想上网必须得通过我， 我需要施展一点点小魔法， 比如说它想访问百度， 通过交换机给我发来这么一个数据帧：</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/6d7d656b-2.png" alt=""></p>
<p>我把数据链路层的外衣去掉， 发现IP数据包中的目标地址是 115.239.211.112， <strong>我就知道这是要向外网发出请求了。</strong></p>
<p>于是我就把IP数据包中的源地址192.168.1.2 替换成我从联通那里搞到的外网地址  61.52.247.112。</p>
<p>这还不够， 我会创建一个新的端口号2001， 把TCP数据包中的源端口也替换掉， 数据包就变成了这个样子：</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/6d7d656b-3.png" alt=""></p>
<p><strong>不知道你看出来其中的奥妙没有，我把源地址和源端口都替换了， 其实我的目的就是让外部的网络认为这是我（路由器）发出的， 他们根本不知道什么TP-Link 7954 这个网卡 ！</strong></p>
<p>然后我需要查一下我的路由表，确定到底转发到哪个输出端口去，再给这个IP数据报穿上数据链路层的外衣，把数据包发给了联通的网络， 剩下的事我就不管了。</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/6d7d656b-4.png" alt=""></p>
<p>注意看以太网帧的MAC地址， 源地址已经是我了，而不是TP-Link 7954了， 因为这是我和联通网络之间的数据链路。</p>
<p>这个替换源地址和源端口的小把戏就叫做<strong>网络地址转换</strong> , 人类简称为<strong>NAT</strong>。</p>
<p>当然不只是TP-Link7954通过我上网， 还有很多别的电脑呢， 我得把我的小把戏记下来 ，形成这么一张表：</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/6d7d656b-5.png" alt=""></p>
<p>过了不久， baidu 网站的回复就会通过别的路由器转到我这里，正如你所想的， 我需要反过来处理一遍：<br>首先去掉数据链路层的外衣，发现TCP和IP数据报中包含这样的信息：<br>目的地IP : 61.52.247.112 , 端口 2001 </p>
<p>这时候我就去查表， 找到了 192.168.1.2:3345  ， 我就明白这是给TP-Link 7954的信了。 </p>
<p>那就再次把数据报中的IP地址和端口号改了吧， 让TP-Link 7954 认为这个数据包就是我给他的。</p>
<p>就这样， 我成功的用区区一个外网的IP就支持了局域网内多个电脑的上网需求， 并且他们根本就不知道是怎么回事！</p>
<h1 id="2-NAT-穿越"><a href="#2-NAT-穿越" class="headerlink" title="2. NAT 穿越"></a>2. NAT 穿越</h1><p>欺骗终究是不能长久的， 我的麻烦很快就来了。</p>
<p>TP-Link 7954 所在的机器为了下载一个大电影， 安装了一个P2P软件： 电驴。 </p>
<p>所谓的P2P 就是Peer to Peer， 即网络中的机器是对等的。</p>
<p>所有使用电驴的机器不仅仅是一个发起请求下载数据的客户端，    他们同时也是一个能够接受请求，向外发送数据的服务器。</p>
<p>这样一来， 当下载大文件的时候， 你就可以从很多安装了电驴的机器上分块下载， 而不是仅仅从一个服务器上下载， 速度快了很多。</p>
<p>人人为我， 我为人人啊。 </p>
<p>可是TP-Link7954 很快就发现， 当它试图做服务器的时候， 其他电驴根本就连不上它， 为什么？ </p>
<p>因为IP地址是我分配的啊， 是个内网地址 192.168.1.2， 外网的人根本就不知道， 怎么连？</p>
<p>TP-Link 7954 给我发了一封措辞严厉的信件，质问我为什么他没法作为一个服务器接受外边的连接， 这强烈的阻碍了他们下载各种电影的需求。</p>
<p>我估摸着是瞒不住了， 只好把所有的网卡都召集起来，开个会大家商量一下。</p>
<p>我解释说： “现在IP地址很稀缺， 我用这种NAT的方法也是不得已而为之，要不然大家怎么上网啊， 你们之前不是过的也挺好吗？ 我听说电驴会占用很大的流量， 我们公司很快就会禁止的。”</p>
<p>D-Link 3925 说 : “公司的政策根本不是你应该考虑的事， 你考虑的是怎么才能让外网的电驴连上我们！”</p>
<p>可是我实在是没有办法， 就这一个外网的IP地址啊。 </p>
<p>TP-Link 7954倒是很聪明，　他立刻就意识到了问题所在，想出了解决办法：</p>
<p>“这样吧，　路由器，你不是擅长搞玩小把戏吗， 可以继续玩下去， 但是得允许我们这些网卡参与进来玩， 比如说我（ip地址192.168.1.2）会主动的要求你建立一个NAT映射 (192.168.1.2 : 4096) &lt;-&gt; (61.52.247.112: 3001)。 </p>
<p>“你还可以保存在你的NAT表中，  然后我就会对外通告了， 我是一个电驴服务器， 谁要是想连接我的话，请到这里来：61.52.247.112: 3001，当外网的连接来的时候， 你必须把连接请求转发到我这里来”</p>
<p>大家一致认为这个方法很简单， 很实用， 就这么决定了。</p>
<p>“码农翻身”公众号注：这其实就是UPnP , 你打开你的无线路由器，就能看到 ：</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/6d7d656b-6.png" alt=""></p>
<p>事情就这么解决了，生活又恢复了平静，当然，我作为一个路由器，这些NAT, UPnP都是我的附加功能， 我最重要的事情还是建立路由表， 做路由选择，转发IP数据包，下次再说吧。</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/coderising.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;amp;mid=2665513173&amp;amp;idx=1&amp;amp;sn=6ec5281b12ed5195070fa4df22383595&amp;amp;scene=1&amp;amp;srcid=0627CDacGQUGTDaYwsDaX5WZ&amp;amp;pass_ticket=QrfnD%2BuaEgpuqOnN6%2FGXOi567jtFjIp2BC3s%2FUjmZiv8wSD%2FZ5ZT%2BQLisdjZLtci#rd&quot;&gt;https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;amp;mid=2665513173&amp;amp;idx=1&amp;amp;sn=6ec5281b12ed5195070fa4df22383595&amp;amp;scene=1&amp;amp;srcid=0627CDacGQUGTDaYwsDaX5WZ&amp;amp;pass_ticket=QrfnD%2BuaEgpuqOnN6%2FGXOi567jtFjIp2BC3s%2FUjmZiv8wSD%2FZ5ZT%2BQLisdjZLtci#rd&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="刘欣-码农翻身" scheme="http://nibnait.com/categories/%E5%88%98%E6%AC%A3-%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB/"/>
    
    
      <category term="转载" scheme="http://nibnait.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="计算机网络" scheme="http://nibnait.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>GeekTools4-一些好玩的安卓应用</title>
    <link href="http://nibnait.com/geektools4/"/>
    <id>http://nibnait.com/geektools4/</id>
    <published>2016-06-16T07:40:52.000Z</published>
    <updated>2016-06-16T07:59:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ShareAll"><a href="#ShareAll" class="headerlink" title="ShareAll"></a>ShareAll</h2><p>手机和其他设备之间进行文件传输</p>
<p>使用方法：MAYBEIWILL这里写的很详细，<a href="http://maybeiwill.me/shareall/" target="_blank" rel="external">http://maybeiwill.me/shareall/</a></p>
<p>下载地址：<a href="https://play.google.com/store/apps/details?id=com.simplesolutions.shareall" target="_blank" rel="external">Play Store</a></p>
<a id="more"></a>
<h2 id="PPIICC"><a href="#PPIICC" class="headerlink" title="PPIICC"></a>PPIICC</h2><p>Android端，一款支持手动拼接的长截图应用</p>
<p>酷安网应用简介&amp;下载地址：<a href="http://www.coolapk.com/apk/bos.consoar.imagestitch" target="_blank" rel="external">http://www.coolapk.com/apk/bos.consoar.imagestitch</a></p>
<p>相信我的可以直接点击下载：<a href="http://7xr7ju.com1.z0.glb.clouddn.com/download/PPIICC_18.apk" target="_blank" rel="external">PPIICC_18.apk</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ShareAll&quot;&gt;&lt;a href=&quot;#ShareAll&quot; class=&quot;headerlink&quot; title=&quot;ShareAll&quot;&gt;&lt;/a&gt;ShareAll&lt;/h2&gt;&lt;p&gt;手机和其他设备之间进行文件传输&lt;/p&gt;
&lt;p&gt;使用方法：MAYBEIWILL这里写的很详细，&lt;a href=&quot;http://maybeiwill.me/shareall/&quot;&gt;http://maybeiwill.me/shareall/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://play.google.com/store/apps/details?id=com.simplesolutions.shareall&quot;&gt;Play Store&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="瞎推荐" scheme="http://nibnait.com/categories/%E7%9E%8E%E6%8E%A8%E8%8D%90/"/>
    
    
      <category term="GeekTools" scheme="http://nibnait.com/tags/GeekTools/"/>
    
  </entry>
  
  <entry>
    <title>【转】我是一个网卡</title>
    <link href="http://nibnait.com/92ac9843-im-a-NIC/"/>
    <id>http://nibnait.com/92ac9843-im-a-NIC/</id>
    <published>2016-06-15T17:37:34.000Z</published>
    <updated>2016-06-27T17:47:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513160&amp;idx=1&amp;sn=d938db4f1a2d62514b57e92fd8d3d749&amp;scene=1&amp;srcid=06274FU4DOq8Xaz86knVlkxe&amp;pass_ticket=QrfnD%2BuaEgpuqOnN6%2FGXOi567jtFjIp2BC3s%2FUjmZiv8wSD%2FZ5ZT%2BQLisdjZLtci#rd0" target="_blank" rel="external">https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513160&amp;idx=1&amp;sn=d938db4f1a2d62514b57e92fd8d3d749&amp;scene=1&amp;srcid=06274FU4DOq8Xaz86knVlkxe&amp;pass_ticket=QrfnD%2BuaEgpuqOnN6%2FGXOi567jtFjIp2BC3s%2FUjmZiv8wSD%2FZ5ZT%2BQLisdjZLtci#rd</a></p>
</blockquote>
<a id="more"></a>
<p>我出生在深圳的一家工厂，然后飘洋过海来到美国，被安装到一个电脑里， 然后这个电脑又漂洋过海， 被运到了中国。</p>
<p>我知道我的使命就是传递信件，但有一个前提：我需要知道对方的地址才行，其实我们网卡都有一个全球唯一的地址，这个地址一出生就确定了，就像你们人类的身份证一样，终生不变。 无论我走到哪里，我都拥有这个唯一的标志：11:27:F5: 8A:79:54 ，  挺长的是吧，你们人类把它叫做MAC地址，  简单起见， 你可以叫我 “TP-Link 7954”</p>
<p>刚开始的时候我非常孤独，因为这台电脑虽然经常开机，但却不联网，真不知道主人是怎么想的！</p>
<p>不上网就没人来找我发信，不发信我也就没什么价值，也没人搭理我，我整天听着CPU阿甘和金士顿内存在那里喋喋不休的聊天，真是烦死了。</p>
<p>只是这两人都记不住对方，每次重启都像是第一次相识，实在是太搞笑了。</p>
<h1 id="1-DHCP"><a href="#1-DHCP" class="headerlink" title="1. DHCP"></a>1. DHCP</h1><p>在我入住机箱30天以后，音箱向大家报告说：“主人终于决定要上网了”  这绝对是个重磅新闻！ </p>
<p>我很兴奋，大家也很兴奋，早就听说外边的世界很精彩了。</p>
<p>一天晚上，只听到“咔嗒”一声， 一个RJ45的网线插头便和我亲密接触了。</p>
<p>网线的那头传来了陌生而熟悉的声音，我的潜意识告诉我，那是交换机在转发信件 。</p>
<p>CPU阿甘看到了这种情况，也不和金士顿内存聊天了，他对着我大叫一声： TP-Link 你在等啥，赶紧上网啊。</p>
<p>这是他第一次和我说话。</p>
<p>操作系统老大是见过世面的，他镇定的说： “心急吃不了热豆腐， 我们得先搞一个IP地址才行。 这需要用到DHCP(动态主机配置协议)”</p>
<p>阿甘说： “谁那里有IP地址啊？”</p>
<p>“这个网络里应该有DHCP 服务器，可以动态的分配地址， 我们可以发个信广播下 ” 老大接着说  “ 阿甘，你和金士顿赶紧写一封信：”</p>
<p>收件人  ： 255.255.255.255  : 67<br>发件人  ： 0.0.0.0   ：68<br>内容： 我想租用一个Ip地址， 谁有啊？</p>
<p>（公众号“码农翻身”注： 这里我做了简化， 实际上这里首先是一个应用层的DHCP发现报文， 然后被一个UDP的报文封装，然后再被一个IP的数据报封装。形象化一点如下图所示）</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/92ac9843-1.png" alt=""></p>
<p>阿甘傻乎乎的， 也不问为什么收件人和发件人这么奇怪， 只是飞快的按老大的指示写信， 信马上写好了，交到我的手里。 </p>
<p>“给你， TP-Link 7954， 赶紧发出去吧”。  </p>
<p>我对外发信是有原则的： 我工作在数据链路层， 必须得知道对方的MAC地址才能发信，   如果不知道， 我就对外广播， 那就是所有的电脑都会收到。</p>
<p>这封信显然就是要广播的，因为到目前为止， 我们还是网络大海中的一个孤岛， 和外界没有任何联系， 我还不知道任何其他电脑的MAC地址。 </p>
<p>按照规定，我又把阿甘写的信封装了一下， 装到另外一个信封里， 只有这样，我最重要的伙伴交换机才能看懂。<br>目的地： FF:FF:FF:FF:FF:FF　（广播到同一子网内的所有电脑）<br>发件人： 11:27:F5:8A:79:54  (就是我自己了！)  </p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/92ac9843-2.png" alt=""></p>
<p>我把它通过网线发给了交换机。  交换机看到FF:FF:FF:FF:FF:FF， 立刻转发给了所有连到交换机的设备。</p>
<p>如同老大所料， 这个局域网里确实有DHCP服务器， 还不止一个！因为没有多久，  交换机转来两封信， 我拆开其中一封， 里边写着：</p>
<p>“我是DHCP服务器192.168.1.1  ， 我这里有个空闲的IP　192.168.1.2，　你租不租？”</p>
<p>另外一封信也差不多， 是另外一个DHCP服务器发来的，提供了另外一个IP地址。</p>
<p>CPU阿甘迫不及待了： “看来我们很受欢迎啊，这么多人愿意给我们IP,  老大， 快抢一个吧。 ”</p>
<p>操作系统老大说： 好， 我们要这个192.168.1.2吧， 再写一封信：<br>“你好，服务器192.168.1.1 , 我们就要这个IP  192.168.1.2了”</p>
<p>我又把这封信广播出去， 看来我们所处的网络非常快， 确认的回信眨眼间就到：<br>“这是一个确认信， IP 192.168.1.2 给你了。 网关路由器是192.168.1.1 , DNS服务器的地址是 202.102.224.69”</p>
<p>金士顿内存说： “不容易啊， 终于搞定一个IP 了， 我把它记下来。 ”</p>
<p>操作系统老大说： “把所有信息都记下来， 接下来很快就会用到”<br>我们的IP : 192.168.1.2<br>网关路由器：  192.168.1.1<br>DNS服务器： 202.102.224.69  </p>
<p>阿甘说：“ 要是重启了， 我们是不是要这么重来一遍？ ”</p>
<p>“阿甘， 你现在越来越聪明了， 确实是这样， 除非主人手动的给我们配置IP地址，网关， DNS ， 但是那样很烦，容易出错，  所以一般情况下， 主人都是依赖我们自动的去用DHCP搞定一个IP 。  ”</p>
<p>经过这一番折腾， 我也初步了解了我们所在的网络结构：</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/92ac9843-3.png" alt=""></p>
<h1 id="2-DNS和ARP"><a href="#2-DNS和ARP" class="headerlink" title="2. DNS和ARP"></a>2. DNS和ARP</h1><p>搞定了IP地址， 大家都喜气洋洋。</p>
<p>我们赶紧把浏览器村的老IE叫来， 让它访问一下著名的google网站。</p>
<p>老IE说： “你们还不知道？  google在中国被屏蔽了， 访问不了，  要不访问百度吧。 ”</p>
<p>我说： “都行， 我们先访问一下试试。 ”</p>
<p>老IE说： ”百度的域名是www.baidu.com, 你们给我查查它对应的IP地址呗！”</p>
<p>阿甘说： “上个网这么麻烦， 这么多地址要查 ”</p>
<p>“是啊， 网络世界的规矩就是这样 ，想要互联， 我们得有IP地址， 也得知道对方的IP地址， 现在只知道域名www.baidu.com , 我们得给他翻译成IP才行， 阿甘你准备一个DNS查询吧  ” 老大说</p>
<p>CPU阿甘遵照指示，先向金士顿内存问了DNS服务器的地址， 然后写了这么一封信， 交给我<br>发件人： 192.168.1.2    (我们刚刚搞定的IP)<br>收件人： 202.102.224.69   (DNS服务器)<br>内容：  哥们， 给我查查www.baidu.com 的IP地址吧  </p>
<p>“但是这封信发给谁呢， 我需要知道对方MAC地址啊， 总不成还是对外广播吧。“ 我心里想。</p>
<p>操作系统老大看出了我的疑虑， 解释说： “DNS服务器不在我们的局域网内，  我们要把这个信发给 网关路由器 ， 他会想办法转给 DNS服务器的。 ”</p>
<p>我说： “可是我不知道网关路由器的MAC地址啊”</p>
<p>金士顿内存说： “别急， 我查查之前我们存下来没有， 我靠， 刚才那个DHCP服务器（192.168.1.1）也是网关服务器, 他怎么没把MAC地址顺便发过来啊！”</p>
<p>CPU阿甘急了： “TP-LINK7954, 你是怎么干活的， 怎么非得要MAC地址， 直接用IP地址不行吗？”</p>
<p>我回答说： “没办法， 这是规定， 你不知道网络是分层的吗？　 我只工作在数据链路层， 就得用MAC地址。   另外网络多种多样， 可不仅仅是TCP/IP , 我要是只用IP地址， 那其他网络怎么工作？”</p>
<p>操作系统老大说：　“我记得好像有个叫ARP东西， 可以通过广播查询一个IP地址对应的MAC地址， 你试试”</p>
<p>其实我也想起来了， 这个ARP叫地址解析协议，  我可以把下面的消息广播出去， 这个子网内的所有机器都会收到， 网关路由器也不例外， 他收到以后，一看是查询自己的MAC地址，  就会创建一个ARP的应答。</p>
<p>收件人： FF:FF:FF:FF:FF:FF　（同一子网内的所有电脑）<br>发件人： 11:27:F5:8A:79:54  (就是我自己了！)<br>内容：呼叫网关路由器（192.168.1.1)， 请问你的MAC地址是什么？  </p>
<p>过了一会， ARP应答果然来了， 我们看到了网关路由器的MAC地址： 88-25-93-79-E0-C8</p>
<p>我告诉金士顿内存：  “赶紧记下来，下次咱就不用再查询了”<br>192.168.1.1    &lt;–&gt; 88-25-93-79-E0-C8</p>
<p>有了网关路由器的MAC地址， 剩下的事情就好办了， 我只需要把之前准备好的DNS查询发给网关路由器即可。</p>
<p>阿甘好奇问我：“ 你只把这个信发到网关路由器， 剩下的事就不管了？ ”</p>
<p>我没声好气的回答它说： “那当然了， 我只能管局域网的事情， 出了局域网， 那就是路由器的事情了， 路由器能抽取这个DNS查询的数据报， 看到收件人是202.102.224.69  (DNS服务器)， 自然可以转发出去， 我们完全不用担心。”</p>
<p>我们等了一会，  DNS服务器很快就返回了www.baidu.com的IP : 115.239.211.112</p>
<p>金士顿内存说： “我记下来了， 上网看来一点都不好玩啊， 这么费劲。 ”</p>
<p>老IE 说： “好玩的在后面呢， 现在所有的东西都齐活了， 开工 ”</p>
<p>老IE开始创建TCP连接， 然后通过TCP 发送HTT GET请求，  轻轻松松的把百度的主页给取了下来，展示了出来。</p>
<p>大家第一次看到外边的世界， 激动万分。</p>
<p>当然还是我最忙， 因为老IE的所有信件都需要我去发送和接收。</p>
<h1 id="3-尾声"><a href="#3-尾声" class="headerlink" title="3. 尾声"></a>3. 尾声</h1><p>这几个月以来我都是电脑里的最忙碌的人， 一旦可以上网， 大家都上瘾了， 浏览网页，刷微博， 看视频， 玩游戏， 每天把我累的要死。</p>
<p>日子就这么一天天过去，  有一天， 大家发现主人把一个新家伙通过USB接口插到了电脑上， 然后顺手拔掉了网线 ！</p>
<p>我失去了和交换机的联系 ， 无法联网了， 难道我们电脑又要成为一个孤岛了吗？</p>
<p>老IE还正在访问一个博客网站呢， 一下子就断了。</p>
<p>不过奇怪的是， CPU阿甘， 金士顿内存， 操作系统老大 竟然都围着新来的家伙重新玩起了DHCP, DNS , ARP , 并且连上网了， 所有的信件都由这个新家伙来传递。</p>
<p>我偷偷的问老IE   :“ 这是怎么回事？ ”</p>
<p>老IE说： “看来你已经失宠了， 新来的家伙叫无线网卡！”</p>
<p>（刘欣注： 这篇文章其实来源于《计算机网络：自顶向下的方法》第5章的一个例子，我相当于又重新解读了一下。）</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/coderising.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;amp;mid=2665513160&amp;amp;idx=1&amp;amp;sn=d938db4f1a2d62514b57e92fd8d3d749&amp;amp;scene=1&amp;amp;srcid=06274FU4DOq8Xaz86knVlkxe&amp;amp;pass_ticket=QrfnD%2BuaEgpuqOnN6%2FGXOi567jtFjIp2BC3s%2FUjmZiv8wSD%2FZ5ZT%2BQLisdjZLtci#rd0&quot;&gt;https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;amp;mid=2665513160&amp;amp;idx=1&amp;amp;sn=d938db4f1a2d62514b57e92fd8d3d749&amp;amp;scene=1&amp;amp;srcid=06274FU4DOq8Xaz86knVlkxe&amp;amp;pass_ticket=QrfnD%2BuaEgpuqOnN6%2FGXOi567jtFjIp2BC3s%2FUjmZiv8wSD%2FZ5ZT%2BQLisdjZLtci#rd&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="刘欣-码农翻身" scheme="http://nibnait.com/categories/%E5%88%98%E6%AC%A3-%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB/"/>
    
    
      <category term="转载" scheme="http://nibnait.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="计算机网络" scheme="http://nibnait.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="http://nibnait.com/7d37b1c4-Factory-Pattern/"/>
    <id>http://nibnait.com/7d37b1c4-Factory-Pattern/</id>
    <published>2016-06-15T06:11:44.000Z</published>
    <updated>2016-06-22T06:59:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>书单列表&amp;参考资料：</p>
<ul>
<li><a href="https://book.douban.com/subject/2334288/" target="_blank" rel="external">《大话设计模式》</a></li>
<li><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="external">《Head First 设计模式（中文版）》</a></li>
<li><a href="http://7xr7ju.com1.z0.glb.clouddn.com/pdf/%E3%80%8A%E6%82%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B.pdf" target="_blank" rel="external">24种设计模式介绍与6大设计原则</a></li>
<li><a href="https://github.com/me115/design_patterns" target="_blank" rel="external">https://github.com/me115/design_patterns</a></li>
</ul>
<a id="more"></a>
<blockquote>
<p> 工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。 </p>
</blockquote>
<h3 id="下面以“女娲造人”为例，为你讲诉三种工厂模式的区别："><a href="#下面以“女娲造人”为例，为你讲诉三种工厂模式的区别：" class="headerlink" title="下面以“女娲造人”为例，为你讲诉三种工厂模式的区别："></a>下面以“女娲造人”为例，为你讲诉三种工厂模式的区别：</h3><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><blockquote>
<p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。  </p>
<p>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端（女娲）可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。</p>
</blockquote>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/7d37b1c4-1.png" alt=""></p>
<h3 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h3><ul>
<li>将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。</li>
<li>在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可，在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源代码。</li>
<li>简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。从而引出了    <em>工厂方法模式</em>。</li>
</ul>
<h3 id="模式应用"><a href="#模式应用" class="headerlink" title="模式应用"></a>模式应用</h3><p>JDK类库中的工具类java.text.DateFormat，它用于格式化一个本地日期或者时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public final static DateFormat getDateInstance();</div><div class="line">public final static DateFormat getDateInstance(int style);</div><div class="line">public final static DateFormat getDateInstance(int style,Locale</div><div class="line">locale);</div></pre></td></tr></table></figure>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><blockquote>
<p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。  </p>
<p>在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p>
</blockquote>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/7d37b1c4-2.png" alt=""></p>
<h3 id="模式分析-1"><a href="#模式分析-1" class="headerlink" title="模式分析"></a>模式分析</h3><p>工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。系统的可扩展性也就变得非常好，完全符合“开闭原则”。</p>
<ul>
<li>缺点：<ul>
<li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li>
<li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li>
</ul>
</li>
</ul>
<h3 id="模式应用-1"><a href="#模式应用-1" class="headerlink" title="模式应用"></a>模式应用</h3><ul>
<li>日志记录器</li>
</ul>
<p>某系统日志记录器要求支持多种日志记录方式，如文件记录、数据库记录等，且用户可以根据要求动态选择日志记录方式， 可使用工厂方法模式设计该系统。</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/7d37b1c4-3.jpg" alt=""></p>
<ul>
<li>JDBC中的工厂方法:（动态链接数据库）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Connection conn=DriverManager.getConnection(&quot;</div><div class="line">	jdbc:mysql://localhost:3306/;DatabaseName=test;user=root;password=123456&quot;);</div><div class="line">Statement statement=conn.createStatement();</div><div class="line">ResultSet rs=statement.executeQuery(&quot;select * from UserInfo&quot;);</div></pre></td></tr></table></figure>
<h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><ul>
<li>创建对象需要大量重复的代码。</li>
<li>创建对象需要访问某些信息，而这些信息不应该包含在复合类中。</li>
<li>创建对象的生命周期必须集中管理，以保证在整个程序中具有一致的行为。</li>
</ul>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/7d37b1c4-4.png" alt=""></p>
<h3 id="模式分析-2"><a href="#模式分析-2" class="headerlink" title="模式分析"></a>模式分析</h3><p>抽象工厂模式与工厂方法模式最大的区别在于，<strong>工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构</strong>，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。更换一个具体工厂变得相对容易，达到了“高内聚低耦合”的设计目的。</li>
<li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。</li>
<li>增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。</li>
<li><strong>“开闭原则”的倾斜性</strong>：增加新的工厂和产品族容易，增加新的产品等级结构麻烦</li>
</ul>
<h3 id="模式应用-2"><a href="#模式应用-2" class="headerlink" title="模式应用"></a>模式应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在很多软件系统中需要更换界面主题，要求界面中的按钮、文本框、背景色等一起发生改变时，可以使用抽象工厂模式进行设计。</div></pre></td></tr></table></figure>
<h3 id="适用环境-1"><a href="#适用环境-1" class="headerlink" title="适用环境"></a>适用环境</h3><ul>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。</li>
<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。</li>
<li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li>
</ul>
<h1 id="三种工厂模式之间的关系（工厂模式的退化）"><a href="#三种工厂模式之间的关系（工厂模式的退化）" class="headerlink" title="三种工厂模式之间的关系（工厂模式的退化）"></a>三种工厂模式之间的关系（工厂模式的退化）</h1><p>当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</p>
<hr>
<ul>
<li>开闭原则：对扩展开放，对修改封闭</li>
<li>“开闭原则”的倾斜性：<ul>
<li>“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的。对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：<ol>
<li>增加产品族：对于增加新的产品族，工厂方法模式很好的支持了“开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。</li>
<li>增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，不能很好地支持“开闭原则”。</li>
</ol>
</li>
<li>抽象工厂模式的这种性质称为“开闭原则”的倾斜性，抽象工厂模式以一种倾斜的方式支持增加新的产品，它为新产品族的增加提供方便，但不能为新的产品等级结构的增加提供这样的方便。</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;书单列表&amp;amp;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/2334288/&quot;&gt;《大话设计模式》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/2243615/&quot;&gt;《Head First 设计模式（中文版）》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://7xr7ju.com1.z0.glb.clouddn.com/pdf/%E3%80%8A%E6%82%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B.pdf&quot;&gt;24种设计模式介绍与6大设计原则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/me115/design_patterns&quot;&gt;https://github.com/me115/design_patterns&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://nibnait.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="设计模式" scheme="http://nibnait.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Git学习笔记</title>
    <link href="http://nibnait.com/264e49bf-Git-StudyNote/"/>
    <id>http://nibnait.com/264e49bf-Git-StudyNote/</id>
    <published>2016-06-15T00:35:44.000Z</published>
    <updated>2016-06-17T09:18:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：  </p>
<ul>
<li><a href="https://git-scm.com/doc" target="_blank" rel="external">https://git-scm.com/doc</a></li>
<li><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="external">git-简明指南</a></li>
<li><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="external">图解Git</a>  </li>
</ul>
<a id="more"></a>
<p>$ git add -A  </p>
<p>$ git commit -m ‘…’  </p>
<p>$ git remote add origin <a href="https://github.com/×××××/××××××××.git" target="_blank" rel="external">https://github.com/×××××/××××××××.git</a>  </p>
<p>$ git push origin master  </p>
<hr>
<p>其他常用命令：  </p>
<ul>
<li>$ git status：查看当前git仓库中文件的状态  </li>
<li>$ git reflog：查看历史commit(提交)记录  </li>
<li><p>$ git reset： 撤销某次提交（版本回滚）</p>
<ul>
<li>$ git reset –hard HEAD 回滚到当前版本库中最新一次提交的那个版本  </li>
<li>$ git reset –hard HEAD^ 倒数第二次  </li>
<li>$ git reset –hard HEAD^^ 倒数第三次</li>
<li>$ git reset –hard HEAD~100 倒数第101次  </li>
<li>$ git reset –hard [commit_id]</li>
</ul>
</li>
<li><p>$ git commit –amend： 修改上一次提交</p>
</li>
</ul>
<blockquote>
<p>$ git add [forgotten_file]</p>
<p>$ git commit –amend</p>
</blockquote>
<ul>
<li>$ git checkout – [file]：撤消对文件的修改【危险】</li>
<li>$ git revert：撤销某次操作【危险】<ul>
<li>$ git revert HEAD~1 倒数第二次的add操作将和commit一起被删除</li>
</ul>
</li>
</ul>
<h2 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h2><ul>
<li>查看分支：$ git branch</li>
<li>新建分支：$ git branch [branchname]</li>
<li>切换分支：$ git checkout [branch]</li>
<li>创建分支并进行切换。：$ git checkout -b [branch]</li>
<li>合并分支：$ git merge [commit]</li>
<li>删除分支：$ git branch -d [branchname]</li>
</ul>
<p>注意：</p>
<ul>
<li>合并分支前，别忘了：git add -A 、git commit -m’×××’ 、</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考资料：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://git-scm.com/doc&quot;&gt;https://git-scm.com/doc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://rogerdudler.github.io/git-guide/index.zh.html&quot;&gt;git-简明指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://marklodato.github.io/visual-git-guide/index-zh-cn.html&quot;&gt;图解Git&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://nibnait.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="git" scheme="http://nibnait.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>有趣的斐波那契数列</title>
    <link href="http://nibnait.com/ca6c3381-Fibonacci/"/>
    <id>http://nibnait.com/ca6c3381-Fibonacci/</id>
    <published>2016-06-14T01:54:52.000Z</published>
    <updated>2016-06-14T08:34:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、起源和定义"><a href="#一、起源和定义" class="headerlink" title="一、起源和定义"></a>一、起源和定义</h1><p>斐波那契数列最早被提出是印度数学家Gopala，他在研究箱子包装物件长度恰好为1和2时的方法数时首先描述了这个数列。也就是这个问题：</p>
<blockquote>
<p>有n个台阶，你每次只能跨一阶或两阶，上楼有几种方法？</p>
</blockquote>
<a id="more"></a>
<p>而最早研究这个数列的当然就是<a href="https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91" target="_blank" rel="external">斐波那契（Leonardo Fibonacci）</a>了，他当时是为了描述如下情况的兔子生长数目：</p>
<blockquote>
<ul>
<li>第一个月初有一对刚诞生的兔子</li>
<li>第二个月之后（第三个月初）它们可以生育</li>
<li>每月每对可生育的兔子会诞生下一对新兔子</li>
<li>兔子永垂不死</li>
</ul>
</blockquote>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/ca6c3381-1.jpg" alt=""></p>
<p>这个数列出自他赫赫有名的大作《计算之书》（没有维基词条，坑），后来就被广泛的应用于各种场合了。这个数列是这么定义的：</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/ca6c3381-2.jpg" alt=""></p>
<h1 id="二、求解方法"><a href="#二、求解方法" class="headerlink" title="二、求解方法"></a>二、求解方法</h1><h2 id="1-递归方法"><a href="#1-递归方法" class="headerlink" title="1. 递归方法"></a>1. 递归方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private static int Fib1(int n) &#123;</div><div class="line">	return n&lt;2? (n&lt;1?0:1) : Fib1(n-1)+Fib1(n-2); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是编程最方便的解法，当然，也是效率最低的解法，原因是会出现大量的重复计算。以f(10)为例，f(10)=f(9)+f(8)，f(9)=f(8)+f(7)。其中的f(8)就是重复计算的。为了避免这种情况，可以采用递推的方式。</p>
<h2 id="2-数组递推方法"><a href="#2-数组递推方法" class="headerlink" title="2. 数组递推方法"></a>2. 数组递推方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">	private static int Fib2(int n) &#123;</div><div class="line"></div><div class="line">	if (n &lt;= 0) &#123;</div><div class="line">		return 0;</div><div class="line">	&#125; else if (n == 1) &#123;</div><div class="line">		return 1;</div><div class="line">	&#125; else &#123;</div><div class="line">		int[] fib = new int[n + 1];</div><div class="line">		fib[0] = 0;</div><div class="line">		fib[1] = 1;</div><div class="line"></div><div class="line">		for (int i = 2; i &lt; n + 1; i++) &#123;</div><div class="line">			fib[i] = fib[i - 1] + fib[i - 2];</div><div class="line">		&#125;</div><div class="line">		return fib[n];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line"> * 优化：利用数组我们保存了每一个中间变量，</div><div class="line"> * 但是仔细观察我们可以发现，当他只想求斐波那契数列的第n个数时，</div><div class="line"> * 没有必要保存每一个中间变量，我们只需要保存两个临时变量即可完成斐波那契数列的计算。</div><div class="line"> */</div><div class="line"></div><div class="line">private static long Fib3(int n) &#123;</div><div class="line">	</div><div class="line">	if (n &lt;= 0) &#123;</div><div class="line">		return 0;</div><div class="line">	&#125; else if (n == 1) &#123;</div><div class="line">		return 1;</div><div class="line">	&#125; else &#123;</div><div class="line"></div><div class="line">		long fibNMinusOne = 0;</div><div class="line">		long fibNMinusTwo = 1;</div><div class="line">		long fibN = 0;</div><div class="line">		</div><div class="line">		for (int i = 2; i &lt; n+1; i++) &#123;</div><div class="line">			fibN = fibNMinusOne + fibNMinusTwo;</div><div class="line">			</div><div class="line">			fibNMinusOne = fibNMinusTwo;</div><div class="line">			fibNMinusTwo = fibN;</div><div class="line">		&#125;</div><div class="line">		return fibN;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>递推的方法可以在O(n)的时间内求出Fib(n)的值。但是这实际还是不够好，因为当n很大时这个算法还是无能为力的。接下来就要来讲一个有意思的东西：矩阵。</p>
<h2 id="3-矩阵递推关系"><a href="#3-矩阵递推关系" class="headerlink" title="3. 矩阵递推关系"></a>3. 矩阵递推关系</h2><p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/ca6c3381-3.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">作者：王希</div><div class="line">链接：https://www.zhihu.com/question/28062458/answer/39763094</div><div class="line">来源：知乎</div><div class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</div><div class="line"></div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">const int MOD = 10000;</div><div class="line"></div><div class="line">struct matrix//定义矩阵结构体</div><div class="line">&#123;</div><div class="line">    int m[2][2];</div><div class="line">&#125;ans, base;</div><div class="line"></div><div class="line">matrix multi(matrix a, matrix b)//定义矩阵乘法</div><div class="line">&#123;</div><div class="line">    matrix tmp;</div><div class="line">    for(int i = 0; i &lt; 2; ++i)</div><div class="line">    &#123;</div><div class="line">        for(int j = 0; j &lt; 2; ++j)</div><div class="line">        &#123;</div><div class="line">            tmp.m[i][j] = 0;</div><div class="line">            for(int k = 0; k &lt; 2; ++k)</div><div class="line">                tmp.m[i][j] = (tmp.m[i][j] + a.m[i][k] * b.m[k][j]) % MOD;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return tmp;</div><div class="line">&#125;</div><div class="line">int fast_mod(int n)  // 求矩阵 base 的  n 次幂 </div><div class="line">&#123;</div><div class="line">    base.m[0][0] = base.m[0][1] = base.m[1][0] = 1;</div><div class="line">    base.m[1][1] = 0;</div><div class="line">    ans.m[0][0] = ans.m[1][1] = 1;  // ans 初始化为单位矩阵 </div><div class="line">    ans.m[0][1] = ans.m[1][0] = 0;</div><div class="line">    while(n)</div><div class="line">    &#123;</div><div class="line">        if(n &amp; 1)  //实现 ans *= t; 其中要先把 ans赋值给 tmp，然后用 ans = tmp * t </div><div class="line">            ans = multi(ans, base);</div><div class="line"></div><div class="line">        base = multi(base, base);</div><div class="line">        n &gt;&gt;= 1;</div><div class="line">    &#125;</div><div class="line">    return ans.m[0][1];</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    while(scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n != -1)</div><div class="line">    &#123;   </div><div class="line">        printf(&quot;%d\n&quot;, fast_mod(n));</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="三、斐波那契数列的数学性质"><a href="#三、斐波那契数列的数学性质" class="headerlink" title="三、斐波那契数列的数学性质"></a>三、斐波那契数列的数学性质</h1><p>知乎大牛王希 讲了好多<a href="https://www.zhihu.com/question/28062458/answer/39763094" target="_blank" rel="external">https://www.zhihu.com/question/28062458/answer/39763094</a></p>
<p>然而 我只看懂了一个，那就是    原来我们中国的杨辉三角中也蕴含着斐波那契数列啊：</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/ca6c3381-4.png" alt=""></p>
<h1 id="四、斐波那契数列的应用"><a href="#四、斐波那契数列的应用" class="headerlink" title="四、斐波那契数列的应用"></a>四、斐波那契数列的应用</h1><h2 id="1-斐波那契堆"><a href="#1-斐波那契堆" class="headerlink" title="1. 斐波那契堆"></a>1. 斐波那契堆</h2><blockquote>
<p>斐波那契堆(Fibonacci heap)是计算机科学中最小堆有序树的集合。它和二项式堆有类似的性质，可&gt;用于实现合并优先队列。特点是不涉及删除元素的操作有O(1)的平摊时间，用途包括稠密图每次&gt;Decrease－key只要O(1)的平摊时间，和二项堆的O(lgn)相比是巨大的改进。</p>
<p>斐波那契堆由一组最小堆构成，这些最小堆是有根的无序树。可以进行插入、查找、合并和删除等操作</p>
<ul>
<li>1）插入：创建一个仅包含一个节点的新的斐波纳契堆，然后执行堆合并</li>
<li>2）查找：由于用一个指针指向了具有最小值的根节点，因此查找最小的节点是平凡的操作。</li>
<li>3）合并：简单合并两个斐波纳契堆的根表。即把两个斐波纳契堆的所有树的根首尾衔接并置。</li>
<li>4）删除（释放）最小节点<br> 分为三步：<ol>
<li>查找最小的根节点并删除它，其所有的子节点都加入堆的根表，即它的子树都成为堆所包含的&gt;树；</li>
<li>需要查找并维护堆的最小根节点，但这耗时较大。为此，同时完成堆的维护：对堆当前包含的树&gt;的度数从低到高，迭代执行具有相同度数的树的合并并实现最小树化调整，使得堆包含的树具有不同的&gt;度数。这一步使用一个数组，数组下标为根节点的度数，数组的值为指向该根节点指针。如果发现具有&gt;相同度数的其他根节点则合并两棵树并维护该数组的状态。</li>
<li>对当前堆的所有根节点查找最小的根节点。</li>
</ol>
</li>
<li>5）降低一个点的键值：对一个节点的键值降低后，自键值降低的节点开始自下而上的迭代执行下&gt;述操作，直至到根节点或一个未被标记（marked）节点为止：<br>如果当前节点键值小于其父节点的键值，则把该节点及其子树摘下来作为堆的新树的根节点；其原父节&gt;点如果是被标记（marked）节点，则也被摘下来作为堆的新树的根节点；如果其原父节点不是被标记&gt;（marked）节点且不是根节点，则其原父节点被加标记。<br>如果堆的新树的根节点被标记（marked），则去除该标记。</li>
<li>6）删除节点：把被删除节点的键值调整为负无穷小，然后执行“降低一个节点的键值”算法，然后&gt;再执行“删除最小节点”算法。</li>
</ul>
</blockquote>
<p>维基百科：<a href="https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86" target="_blank" rel="external">斐波那契堆</a></p>
<h2 id="2-欧几里得算法的时间复杂度"><a href="#2-欧几里得算法的时间复杂度" class="headerlink" title="2. 欧几里得算法的时间复杂度"></a>2. 欧几里得算法的时间复杂度</h2><p>欧几里得算法是求解两个正整数最大公约数的算法，又称辗转相除法。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public static int gcd(int p, int q)&#123;</div><div class="line">	return q==0 ? p : gcd(q, p%q);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在最坏的情况下，我们可以证明，若p较小，需要计算的次数为n，则 p&gt;F(n-1).</p>
<h2 id="3-斐波那契螺旋"><a href="#3-斐波那契螺旋" class="headerlink" title="3. 斐波那契螺旋"></a>3. 斐波那契螺旋</h2><p>斐波那契螺旋又称黄金螺旋，在自然界中广泛存在。如图是一个边长为斐波那契数列的正方形组成的矩形。</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/ca6c3381-5.png" alt=""></p>
<p>贝壳螺旋轮廓线  </p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/ca6c3381-6.png" alt=""></p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/ca6c3381-7.png" alt=""></p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/ca6c3381-8.png" alt=""></p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/ca6c3381-9.png" alt=""></p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/ca6c3381-10.png" alt=""></p>
<p>神奇的花：</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/ca6c3381-11.png" alt=""></p>
<p>建筑学：</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/ca6c3381-12.png" alt=""></p>
<p>斐波那契螺旋形的摇椅：</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/ca6c3381-13.png" alt=""></p>
<p>感谢你读到了最后，</p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/ca6c3381-14.png" alt="彩蛋"></p>
<p>参考资料：</p>
<ul>
<li><a href="https://www.zhihu.com/question/28062458/answer/39763094" target="_blank" rel="external">Fibonacci数列为什么那么重要</a></li>
<li><a href="http://www.cnblogs.com/hlxs/archive/2011/07/15/2107389.html" target="_blank" rel="external">7种方式实现斐波那契数列</a> 啊汉这逼装的，可以。。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、起源和定义&quot;&gt;&lt;a href=&quot;#一、起源和定义&quot; class=&quot;headerlink&quot; title=&quot;一、起源和定义&quot;&gt;&lt;/a&gt;一、起源和定义&lt;/h1&gt;&lt;p&gt;斐波那契数列最早被提出是印度数学家Gopala，他在研究箱子包装物件长度恰好为1和2时的方法数时首先描述了这个数列。也就是这个问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有n个台阶，你每次只能跨一阶或两阶，上楼有几种方法？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="随便聊聊" scheme="http://nibnait.com/categories/%E9%9A%8F%E4%BE%BF%E8%81%8A%E8%81%8A/"/>
    
    
      <category term="数据结构与算法" scheme="http://nibnait.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://nibnait.com/aa7abc25-Singleton-Pattern/"/>
    <id>http://nibnait.com/aa7abc25-Singleton-Pattern/</id>
    <published>2016-06-14T01:32:35.000Z</published>
    <updated>2016-06-22T06:59:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>书单列表&amp;参考资料：</p>
<ul>
<li><a href="https://book.douban.com/subject/2334288/" target="_blank" rel="external">《大话设计模式》</a></li>
<li><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="external">《Head First 设计模式（中文版）》</a></li>
<li><a href="http://7xr7ju.com1.z0.glb.clouddn.com/pdf/%E3%80%8A%E6%82%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B.pdf" target="_blank" rel="external">24种设计模式介绍与6大设计原则</a></li>
</ul>
<a id="more"></a>
<p>目录：</p>
<ul>
<li>单利模式的</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>系统只需要一个实例对象时，如：</p>
<ul>
<li>系统要求提供一个唯一的<strong>序列号生成器</strong>、<strong>网站的计数器</strong></li>
<li>具有资源管理器功能的应用：<strong>线程池</strong>、缓存、日志、对话、打印机等</li>
<li>当创建一个对象需要消耗的资源（访问IO和数据库等资源）过多时，最好也设计成单例的</li>
</ul>
<h2 id="几种实现的示例代码"><a href="#几种实现的示例代码" class="headerlink" title="几种实现的示例代码"></a>几种实现的示例代码</h2><h3 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1. 饿汉式"></a>1. 饿汉式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class Singleton&#123;</div><div class="line">    //类加载时就初始化</div><div class="line">    private static final Singleton instance = new Singleton();</div><div class="line">    </div><div class="line">    private Singleton()&#123;&#125;	//private 保证不被其他类new出来</div><div class="line"></div><div class="line">    public static Singleton getInstance()&#123;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-懒汉式"><a href="#2-懒汉式" class="headerlink" title="2. 懒汉式"></a>2. 懒汉式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class Singleton &#123;</div><div class="line">    private static Singleton instance;</div><div class="line">    private Singleton ()&#123;&#125;</div><div class="line"></div><div class="line">    public static Singleton getInstance() &#123;</div><div class="line">		if (instance == null) &#123;</div><div class="line">			instance = new Singleton();</div><div class="line">		&#125;</div><div class="line">		return instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-懒汉式线程安全的"><a href="#3-懒汉式线程安全的" class="headerlink" title="3. 懒汉式线程安全的"></a>3. 懒汉式线程安全的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public static synchronized Singleton getInstance() &#123;</div><div class="line">    if (instance == null) &#123;</div><div class="line">        instance = new Singleton();</div><div class="line">    &#125;</div><div class="line">    return instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="双重检验锁模式"><a href="#双重检验锁模式" class="headerlink" title="双重检验锁模式"></a>双重检验锁模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class Singleton &#123;</div><div class="line"> 		//注意 volatile 是必须的，否则 JVM 可能会进行优化（指令重排）导致错误</div><div class="line">    private volatile static Singleton instance; </div><div class="line">    private Singleton ()&#123;&#125;</div><div class="line"></div><div class="line">    public static Singleton getSingleton() &#123;</div><div class="line">        if (instance == null) &#123;                         </div><div class="line">            synchronized (Singleton.class) &#123;</div><div class="line">                if (instance == null) &#123;       </div><div class="line">                    instance = new Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-静态内部类"><a href="#4-静态内部类" class="headerlink" title="4. 静态内部类"></a>4. 静态内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class Singleton &#123;  </div><div class="line">    private static class SingletonHolder &#123;  </div><div class="line">        private static final Singleton INSTANCE = new Singleton();  </div><div class="line">    &#125;  </div><div class="line">    private Singleton ()&#123;&#125;  </div><div class="line">    public static final Singleton getInstance() &#123;  </div><div class="line">        return SingletonHolder.INSTANCE; </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只有在调用 getInstance() 时，对象才会被创建，同时没有性能缺点，也不依赖 Java 版本。</p>
<h3 id="5-枚举"><a href="#5-枚举" class="headerlink" title="5. 枚举"></a>5. 枚举</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public enum Singleton &#123;</div><div class="line">    INSTANCE;</div><div class="line">    public static Singleton getInstance() &#123;</div><div class="line">        return INSTANCE;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>默认枚举实例的创建是线程安全的，所以不需要担心线程安全的问题</p>
<h2 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>由于单例模式在内存中只有一个实例，减少了内存开支（特别是<strong>一个对象需要频繁地创建、销毁时</strong>）。</li>
<li>减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如<strong>读取配置、产生其他依赖对象时</strong>，则可以通过在应用启动时直接产生一个单例对象，然后用永久驻留内存的方式来解决。</li>
<li>单例模式可以在系统设置全局的访问点，优化和共享资源访问（例如可以设计一个单例类，负责<strong>所有数据表的映射处理</strong>）。</li>
<li>避免对资源的多重占用（例如一个写文件动作，由于只有一个实例存在内存中，<strong>避免对同一个资源文件的同时写操作</strong>）。</li>
<li>允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3></li>
<li>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</li>
<li>单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</li>
<li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;书单列表&amp;amp;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/2334288/&quot;&gt;《大话设计模式》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/2243615/&quot;&gt;《Head First 设计模式（中文版）》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://7xr7ju.com1.z0.glb.clouddn.com/pdf/%E3%80%8A%E6%82%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B.pdf&quot;&gt;24种设计模式介绍与6大设计原则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://nibnait.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="设计模式" scheme="http://nibnait.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【转】设计模式概述</title>
    <link href="http://nibnait.com/14c1f5fd-Overview-of-Design-Patterns/"/>
    <id>http://nibnait.com/14c1f5fd-Overview-of-Design-Patterns/</id>
    <published>2016-06-14T00:08:08.000Z</published>
    <updated>2016-06-18T14:15:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的代码设计经验的总结。使用设计模式是为了<strong>可重用代码、让代码更容易被他人理解、保证代码可靠性</strong>。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。</p>
</blockquote>
<a id="more"></a>
<p><span style="opacity:0">asdf</span>可以看出，23种设计模式也不是凭空捏造出来的，而是经过了反复的推敲修改以及诸多的项目实战总结而出的代码设计经验。因此，能作为一种模式（pattern），设计模式不再是代码的罗列，而是扎实的逻辑结构，每一种设计模式都拥有成熟的思想。</p>
<h1 id="设计模式的发展"><a href="#设计模式的发展" class="headerlink" title="设计模式的发展"></a>设计模式的发展</h1><p><span style="opacity:0">asdf</span>既然是“模式”，那么容易得出设计模式可以应用于各种各样的编程语言中，而且所得出的表现都应该是一样的。对于一些像是C#、Java、C++这样的比较明确的面向对象的语言，一种设计模式在各语言之间的转换都是比较容易的，只是语法不同而已。但是，JavaScript作为一种弱类型的切十分灵活的语言，甚至没有明确的class这个关键字，随着Node和HTML5以及web2.0的兴起才开始受到比较多的重视，设计模式对她来讲就和变得和别的语言不同。但是，很多东西Javascript都有，只是没有作为正式的部分。而设计模式又是一种编程的思想，思想是相同的，一旦你掌握了这种思想，代码就可以相通，利用一些javascript的特性来实现各种设计模式应该也不是一件特别难的事情。</p>
<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><p><span style="opacity:0">asdf</span>面向对象程序设计有几个原则：开闭原则、里氏转换原则、依赖倒转原则、接口隔离原则、合成/聚合复用原则、最小知识原则。开闭原则具有理想主义的色彩，它是面向对象设计的终极目标。设计模式正是通过实现这些原则来达到代码复用、增强可维护性的目的。 </p>
<p><strong>这些原则并不是固定的，任何人都可以提出更好的原则</strong></p>
<h2 id="开闭原则（Open-Closed-Principle，OCP）"><a href="#开闭原则（Open-Closed-Principle，OCP）" class="headerlink" title="开闭原则（Open Closed Principle，OCP）"></a>开闭原则（Open Closed Principle，OCP）</h2><p><span style="opacity:0">asdf</span>模块应<strong>对扩展开放，而对修改关闭</strong>。模块应尽量在不修改原来的代码的情况下进行扩展。<br><span style="opacity:0">asdf</span>举个例子，假设现在有一个已经开发完成的规模不小的软件系统，有人提需求说我要再加一个功能，那么这时候去修改源代码显然是不明智的，不仅违反了开闭原则，而且那么多的代码，工作量肯定也很大。为了要实现这个需求，可以在原来的软件系统中扩展出来一个功能，只需要编写调试这个新功能模块的代码，这就是开放扩展，关闭修改。</p>
<h2 id="里氏代换原则（Liskov-Substitution-Principle，LSP）"><a href="#里氏代换原则（Liskov-Substitution-Principle，LSP）" class="headerlink" title="里氏代换原则（Liskov Substitution Principle，LSP）"></a>里氏代换原则（Liskov Substitution Principle，LSP）</h2><p><span style="opacity:0">asdf</span>里氏代换原则是由Barbara Liskov提出的。可以描述为：<strong>子类继承于父类，可以单独调用，如果调用的是父类的话，那么换成子类也完全可以运行。</strong>从开闭原则可以看出，设计模式一个重要的部分是抽象化，里氏代换原则从另一个角度描述了抽象（父类）和具体（子类）之间的关系。举例，猫科动物可以完成捕猎这个动作，而老虎也可以完成捕猎，在这个例子中，猫科动物就是父类，老虎是继承于猫科动物、从猫科动物这个类扩展出来的子类。<br>可以说：<strong>里氏代换原则是继承复用的一个基础。</strong></p>
<h2 id="依赖倒转原则（Dependency-Inversion-Principle，DIP）"><a href="#依赖倒转原则（Dependency-Inversion-Principle，DIP）" class="headerlink" title="依赖倒转原则（Dependency Inversion Principle，DIP）"></a>依赖倒转原则（Dependency Inversion Principle，DIP）</h2><p><span style="opacity:0">asdf</span><strong>若引用的对象有底层类型，那么就直接引用底层类型。高层模块不应该依赖于底层模块</strong>。<br><span style="opacity:0">asdf</span>换句话说，在程序里面调用的时候调用子类 ，子类依赖于父类，而父类不要依赖于子类。也就是说，细节依赖于抽象，可是抽象不应该依赖于细节。<br>依赖倒转原则要求程序设计时应该考虑如何针对抽象编程。<br><span style="opacity:0">asdf</span>以计算机系统为例，依赖倒转原则要求要<strong>针对接口编程</strong>，而不是针对实现编程。无论键盘鼠标、CPU、内存等等这些硬件都是针对接口设计的，而如果要针对实现来设计，硬盘就要对应到某个特定（品牌/类型）的主板，那么换硬盘时就需要把主板也换掉。</p>
<h2 id="接口隔离原则（Interface-Segregation-Principle，ISP）"><a href="#接口隔离原则（Interface-Segregation-Principle，ISP）" class="headerlink" title="接口隔离原则（Interface Segregation Principle，ISP）"></a>接口隔离原则（Interface Segregation Principle，ISP）</h2><p><span style="opacity:0">asdf</span><strong>每一个接口都是一个角色，客户端不应该依赖于它不需要的接口。</strong><br><span style="opacity:0">asdf</span>也就是：一个类对另一个类的依赖应该建立在最小的接口上。<br><span style="opacity:0">asdf</span>意思是这样的：应该把每一个<strong>接口都细化，针对类去设计接口。</strong>如果一个接口里含有太多的方法，而对很多类来说里面的很多方法都是用不到的，那么另外的类在实现这个接口时就要实现很多对它来说没用的方法，浪费人力物力。对一个类来说，实现很多它都能用得上的专用接口总比让它实现一个臃肿而又有很多它用不上的方法要划得来。</p>
<blockquote>
<p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p>
<p>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。<br>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。<br>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</p>
</blockquote>
<p><span style="opacity:0">asdf</span>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。</p>
<h2 id="合成-聚合复用原则（Composite-Aggregate-Reuse-Principle，CARP）"><a href="#合成-聚合复用原则（Composite-Aggregate-Reuse-Principle，CARP）" class="headerlink" title="合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）"></a>合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）</h2><p><span style="opacity:0">asdf</span>了解这个原则应首先了解一下组合和聚合。</p>
<blockquote>
<p>组合（合成）和聚合都是对象关系的一种。<strong>聚合</strong>表示整体与部分的关系，表示“含有”，整体由部分组合而成，部分可以脱离整体作为一个独立的个体存在。<strong>组合（合成）</strong>则是一种更强的聚合，部分组成整体，而且不可分割，部分不能脱离整体而单独存在。在组合（合成）关系中，部分和整体的生命周期一样，组合的新的对象完全支配其组成部分，包括他们的创建和销毁。 </p>
</blockquote>
<p><span style="opacity:0">asdf</span>复用原则的设计原则是：要<strong>尽量使用合成/聚合，尽量不要使用继承</strong></p>
<h2 id="最小知识原则（Principle-of-Least-Knowledge，PLK，也叫迪米特法则）"><a href="#最小知识原则（Principle-of-Least-Knowledge，PLK，也叫迪米特法则）" class="headerlink" title="最小知识原则（Principle of Least Knowledge，PLK，也叫迪米特法则）"></a>最小知识原则（Principle of Least Knowledge，PLK，也叫迪米特法则）</h2><p><span style="opacity:0">asdf</span>一句话，一个对象应对其他对象有尽可能少的了解。</p>
<h1 id="基本模式"><a href="#基本模式" class="headerlink" title="基本模式"></a>基本模式</h1><ol>
<li>创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。</li>
<li>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。</li>
<li>行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。</li>
</ol>
<hr>
<p>原文地址：<a href="http://blog.csdn.net/panda_m/article/details/50119439" target="_blank" rel="external">http://blog.csdn.net/panda_m/article/details/50119439</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的代码设计经验的总结。使用设计模式是为了&lt;strong&gt;可重用代码、让代码更容易被他人理解、保证代码可靠性&lt;/strong&gt;。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://nibnait.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="转载" scheme="http://nibnait.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="设计模式" scheme="http://nibnait.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【转】Java 帝国之函数式编程（下）</title>
    <link href="http://nibnait.com/bbefa7a0-JavaEmpire-Functional-Programming-2/"/>
    <id>http://nibnait.com/bbefa7a0-JavaEmpire-Functional-Programming-2/</id>
    <published>2016-06-11T17:10:07.000Z</published>
    <updated>2016-06-27T18:07:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513152&amp;idx=1&amp;sn=1398826ca9f9ea2b7c374574302a3838&amp;scene=1&amp;srcid=0627Vs6gpX1RXltwH34v77aL&amp;pass_ticket=QrfnD%2BuaEgpuqOnN6%2FGXOi567jtFjIp2BC3s%2FUjmZiv8wSD%2FZ5ZT%2BQLisdjZLtci#rd" target="_blank" rel="external">https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513152&amp;idx=1&amp;sn=1398826ca9f9ea2b7c374574302a3838&amp;scene=1&amp;srcid=0627Vs6gpX1RXltwH34v77aL&amp;pass_ticket=QrfnD%2BuaEgpuqOnN6%2FGXOi567jtFjIp2BC3s%2FUjmZiv8wSD%2FZ5ZT%2BQLisdjZLtci#rd</a></p>
</blockquote>
<a id="more"></a>
<p>上一篇文章<a href="http://nibnait.com/62620fba-JavaEmpire-Functional-Programming-1/">《Java帝国之函数式编程（上）》</a>说到Java帝国为了迎合函数式编程的狂热分子，决定为Java语言加上Labmda表达式。</p>
<p>同时为了展示“声明式”编程的魅力， 小码哥决定加上一个新的概念: Stream。</p>
<p>等到一切准备停当，  我们召开了一场开发者大会， 决定隆重推出Java 函数式编程。 </p>
<h1 id="1-Stream"><a href="#1-Stream" class="headerlink" title="1. Stream"></a>1. Stream</h1><p>小码哥首先展示了Labmda表达式 和 类型推断， 大家还比较满意， 台下有人说：</p>
<p>“嗯， 和微软的C#长的挺像的， 人家用 =&gt;   ,我们用 -&gt;   ”</p>
<p>等到小码哥开始介绍Stream的时候， 下面就有人发难了：</p>
<p>“我们不是已经有IO流了吗， 字节流，字符流， 怎么又搞个流出来？”</p>
<p>小码哥赶紧解释： “这个Stream和IO流是不一样的， 这是个新的概念， 主要是为了实现LISP中常见的延迟计算（或者惰性求值）的功能”</p>
<p>看到下面的人开始交头接耳， 小码哥说： “大家别着急，先看看这一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class EvenNumber implements </div><div class="line">                    Supplier&lt;Long&gt;&#123;</div><div class="line">    long num = 0;</div><div class="line">    @Override</div><div class="line">    public Long get() &#123;</div><div class="line">        num += 2;</div><div class="line">        return num ;</div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果持续调用这个类的get()方法， 就可以得到所有的偶数， 现在我们就可以用它产生一个流:</p>
<blockquote>
<p>Stream<long> numbers = Stream.generate(<br>new EvenNumber());</long></p>
</blockquote>
<p>这个Stream 其实就代表了一个无穷无尽的偶数序列， 只是它还没有计算出来而已( 惰性的/延迟的)<br>如果试图打印每个元素，那就开始计算了，  你就发现它会一直运行下去</p>
<blockquote>
<p>numbers.forEach(x-&gt;System.out.println(x));</p>
</blockquote>
<p>当然，无限的序列是无意义的， 各位在编程中肯定会限定长度的： </p>
<p>numbers.limit(5).forEach(x-&gt;System.out.println(x));<br>输出： 2 4 6 8 10</p>
<h1 id="2-延迟计算"><a href="#2-延迟计算" class="headerlink" title="2. 延迟计算"></a>2. 延迟计算</h1><p>现在台下的人安静了，  小码哥有了信心， 开始介绍对Java 集合框架的改进：</p>
<p>“为了方便大家使用函数式风格，我们对集合框架中的类库做了极大的增强， 每个集合都可以变成一个stream ， 然后就可以使用那些著名的map , reduce , filter 等函数了</p>
<blockquote>
<p>Arrays.asList(“Hello”,”Java8”,”Java7”).<strong>stream()</strong><br><span style="opacity:0">asdfas</span><strong>.map</strong>(s -&gt; s.toUpperCase())         </p>
</blockquote>
<p>map 是个高阶函数， 它接受了一个Labmda表达式（匿名函数）作为参数， 把Stream中的元素做了变换： 字符串变成了大写 ， 然后返回了一个新的Stream </p>
<p>这也是延迟计算， 即使你加了一个打印语句， 也不会有任何任何输出：</p>
<blockquote>
<p>Arrays.asList(“Hello”,”Java8”,”Java7”).stream()<br><span style="opacity:0">asdf</span>.map(s -&gt; {<br><span style="opacity:0">asdfasdf</span><strong>System.out.println(s);</strong><br><span style="opacity:0">asdfasdf</span>return s.toUpperCase();<br><span style="opacity:0">asdfasdf</span>});</p>
</blockquote>
<p>由于map 返回了一个新的Stream， 可以在新的Stream上继续操作, 例如filter :  把以J开头的字符串找出来，  filter 的结果仍然是个Stream.</p>
<blockquote>
<p>Arrays.asList(“Hello”,”Java8”,”Java7”).stream()<br><span style="opacity:0">asdf</span><strong>.map</strong>(s -&gt;s.toUpperCase())<br><span style="opacity:0">asdf</span><strong>.filter</strong>(s -&gt; s.startsWith(“J”));</p>
</blockquote>
<p>最后你就可以用forEach 输出了，和惰性求值相反， forEach 是个立即求值的函数：</p>
<blockquote>
<p>Arrays.asList(“Hello”,”Java8”,”Java7”).stream()<br><span style="opacity:0">asdf</span><strong>.map</strong>(s -&gt;s.toUpperCase())<br><span style="opacity:0">asdf</span><strong>.filter</strong>(s -&gt; s.startsWith(“J”))<br><span style="opacity:0">asdf</span><strong>.forEach</strong>(s -&gt; System.out.println(s));</p>
</blockquote>
<p>如你所料，  这里的输出是：  </p>
<blockquote>
<p>JAVA 8<br>JAVA 7</p>
</blockquote>
<p>台下有人举手问到： “既然是延迟计算， 那列表中的元素在流中到底是怎么处理的？”</p>
<p>小码哥回答：“这是个好问题， 我们加点打印语句看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Arrays.asList(&quot;Hello&quot;,&quot;Java8&quot;,&quot;Java7&quot;).stream()</div><div class="line">        .map(s -&gt; &#123;</div><div class="line">            System.out.println(&quot;map: &quot;+ s);</div><div class="line">            return s.toUpperCase();&#125;)</div><div class="line">        .filter(s -&gt; &#123;</div><div class="line">            System.out.println(&quot;filter:&quot;+ s);</div><div class="line">            return s.startsWith(&quot;J&quot;);&#125;)</div><div class="line">        .forEach(s -&gt; System.out.println(s));</div></pre></td></tr></table></figure>
<p>系统的输出是这样的：</p>
<blockquote>
<p>map: Hello<br>filter:HELLO<br>map: Java8<br>filter:JAVA8<br>JAVA8<br>map: Java7<br>filter:JAVA7<br>JAVA7</p>
</blockquote>
<p>由此可以看出， 系统先取到初始Stream 中的第一个元素“Hello” , 做map操作，变成 “HELLO”,  然后传递给 filter , filter 做了判断， 发现不是以”J” 开头的字符串， 立刻停止， 不会走到forEach那里。</p>
<p>接下来取第二个元素”Java8 “, 再经过map, filter, 这时候发现符合规则， 就走到了forEach 那里， 打印出来了。 </p>
<p>对第三个元素“Java 7” 也是类似处理</p>
<p>还有人问道：　“s -&gt;s.toUpperCase()  是不是和java.util.function.Function  这个接口相匹配？</p>
<p>小码哥说： “是的， 这是JDK内置的一个接口， 还有那个s-&gt;s.startsWith(“J”)  和 java.util.function.Predicate  匹配,  这是为了方便大家编程， 不用自己写函数接口了”</p>
<p>“除了map, filter, 还有哪些可以用的内置函数？”</p>
<p>小码哥说： “我们内置了很多， 像reduce , max ,min , collect, flatMap, 大家可以看看我们会议分发的手册， 使用这些函数， 我们就不用考虑集合处理的细节了， 基本上能做到声明式编程了。”</p>
<p>我看出大家有点小失望， 毕竟和纯正的函数式编程相差还比较远， 只能说是给面向对象的Java 增加了一点函数式的特性。 </p>
<h1 id="3-函数式编程的好处"><a href="#3-函数式编程的好处" class="headerlink" title="3. 函数式编程的好处"></a>3. 函数式编程的好处</h1><p>这时候台下有个热爱Ruby 的家伙叫了起来： “啊 ！  我知道怎么利用Java函数式编程写出Ruby 风格的代码了，举个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class Connection &#123;</div><div class="line">    public void open()&#123;</div><div class="line">        System.out.println(&quot;Open connection&quot;);</div><div class="line">    &#125;</div><div class="line">    public void close()&#123;</div><div class="line">        System.out.println(&quot;Close connection&quot;);</div><div class="line">    &#125;</div><div class="line">    public void read()&#123;</div><div class="line">        System.out.println(&quot;Read from connection&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正常的使用是这样的， 调用方很麻烦， 得用try finally 确保连接关闭。</p>
<blockquote>
<p>Connection conn = new Connection();<br>conn.open();<br>try{<br><span style="opacity:0">asdf</span>conn.read();<br>}finally{<br><span style="opacity:0">asdf</span>// 一定得确保连接在finally中关闭<br><span style="opacity:0">asdf</span>conn.close();<br>}</p>
</blockquote>
<p>有了函数式编程， 我们可以在Connection 添加这么一个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class Connection &#123;</div><div class="line">    ......</div><div class="line"> 	注意这个方法, 它已经把打开连接，关闭连接搞定了    </div><div class="line">	......</div><div class="line">	public static void open(</div><div class="line">        Consumer&lt;Connection&gt; consumer)&#123;</div><div class="line">        Connection conn = new Connection();</div><div class="line">        conn.open();</div><div class="line">        try&#123;</div><div class="line">            consumer.accept(conn);</div><div class="line">        &#125;finally&#123;</div><div class="line">            conn.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后调用方就简单了： </p>
<p><strong>Connection.open(conn -&gt; conn.read());</strong></p>
<p>用这种方式， 调用方根本不用处理连接的打开和关闭问题了 ！  只需要关注自己想要调用的逻辑<br>实在是太爽了！</p>
<p>这和Ruby 风格非常像 :</p>
<blockquote>
<p>Connection.open do |conn|<br><span style="opacity:0">asdf</span>conn.read<br>end</p>
</blockquote>
<p>我和小码哥都大喜过望： 没有想到还有这么一个同盟军 ！ </p>
<p>另外一个家伙说：“这的确是个好例子， 其实大家想想在java 世界大行其道的设计模式， 很多时候设计模式就是想把一个行为封装起来， 到处传递而已， 只是当时我们没有函数式编程的概念， 只好用个类来封装一个行为，显得很笨拙， 最典型的就是策略模式。”</p>
<p>小码哥回应说： “对的， 大家可以充分的发掘一下函数式编程的威力， 不但可以简化集合框架的操作， 还能简化代码，  简化设计模式， 甚至也能向Ruby那样，开发出领域特定语言(DSL)出来 。 ”</p>
<h1 id="4-并行"><a href="#4-并行" class="headerlink" title="4. 并行"></a>4. 并行</h1><p>我看发布会临近尾声， 小码哥竟然还没有介绍并行化， 赶紧提醒他： 小码，快讲讲数据并行化啊。</p>
<p>“对了， Java 函数式编程还给大家提供了另外一件福利：并行化“ 小码哥终于要补上这一项了</p>
<p>“把代码变成并行化代码异常简单， 只需要把stream()操作改成 parallelStream() 就可以了， 例如下面这个计算素数的程序”</p>
<blockquote>
<p>List<integer> numbers= …..<br>List<integer> prims = numbers.<strong>parallelStream()</strong><br><span style="opacity:0">asdf</span>.filter(i -&gt; Util.isPrim(i) )<br><span style="opacity:0">asdf</span>.collect(Collectors.toList())</integer></integer></p>
</blockquote>
<p>“再比如对数组的并行排序：Arrays.<strong>parallelSort()</strong>， 只需要做一点点改动， 剩下的工作就交由Java 来完成了， 我们会把数据自动进行分块， 分配到各个CPU核心上去运行， 最后把结果收集回来， 一个简单的变化就能极大的提升性能。”</p>
<p>我听到台下响起了欢呼声！</p>
<p>但是小码哥接着就泼了一盆冷水： ”使用并行stream的时候要注意，它不一定100%能提高性能，因为这依赖很多因素 ，例如输入的数据是否容易分解成块， 是不是CPU密集型的任务， 有没有IO等待操作等等…… ”</p>
<p>我就知道技术人员太老实 ，不会忽悠， 眼瞅着热烈的气氛要冷却下来，  我赶紧上台， 抢过话筒说： “这些细节大家下来再和小码哥聊吧， 我们今天的发布会就到这里， 再见。” </p>
<p>Java 的函数式编程就这么发布了， 帝国程序员的工具箱里又多了一件工具，  虽然不是纯正的函数式编程， 但我们确实可以用它来写出更简洁的代码， 希望大家能够喜欢它。 </p>
<p><img src="http://7xr7ju.com1.z0.glb.clouddn.com/image/coderising.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;amp;mid=2665513152&amp;amp;idx=1&amp;amp;sn=1398826ca9f9ea2b7c374574302a3838&amp;amp;scene=1&amp;amp;srcid=0627Vs6gpX1RXltwH34v77aL&amp;amp;pass_ticket=QrfnD%2BuaEgpuqOnN6%2FGXOi567jtFjIp2BC3s%2FUjmZiv8wSD%2FZ5ZT%2BQLisdjZLtci#rd&quot;&gt;https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;amp;mid=2665513152&amp;amp;idx=1&amp;amp;sn=1398826ca9f9ea2b7c374574302a3838&amp;amp;scene=1&amp;amp;srcid=0627Vs6gpX1RXltwH34v77aL&amp;amp;pass_ticket=QrfnD%2BuaEgpuqOnN6%2FGXOi567jtFjIp2BC3s%2FUjmZiv8wSD%2FZ5ZT%2BQLisdjZLtci#rd&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="刘欣-码农翻身" scheme="http://nibnait.com/categories/%E5%88%98%E6%AC%A3-%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB/"/>
    
    
      <category term="转载" scheme="http://nibnait.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="Java番外篇" scheme="http://nibnait.com/tags/Java%E7%95%AA%E5%A4%96%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>将Hexo部署到vps上</title>
    <link href="http://nibnait.com/4480603d-VPS-building-Hexo/"/>
    <id>http://nibnait.com/4480603d-VPS-building-Hexo/</id>
    <published>2016-06-11T08:57:08.000Z</published>
    <updated>2016-06-17T11:14:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：</p>
<ul>
<li><a href="http://tiktoking.github.io/2016/01/26/hexo/#" target="_blank" rel="external">WikiLibrary | 在VPS上搭建hexo博客，利用git更新</a></li>
<li><a href="http://www.hansoncoder.com/2016/03/02/VPS-building-Hexo/" target="_blank" rel="external">VPS(CentOS)搭建Hexo博客与Git Hooks更新（小白篇）</a></li>
<li><a href="http://hejun.me/2015/01/05/deploy-hexo-on-cloud/" target="_blank" rel="external">在云服务器上搭建HEXO博客环境</a></li>
<li><a href="http://www.cnblogs.com/zhoulf/archive/2013/02/09/2909653.html" target="_blank" rel="external">Linux系统 - 源码编译安装Nginx</a></li>
<li><a href="http://www.jianshu.com/p/d5114a2a2052" target="_blank" rel="external">Centos下 Nginx安装与配置</a></li>
</ul>
<a id="more"></a>
<h1 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h1><p>在本地生成静态文件，把静态文件部署到VPS上，用Nginx直接做Web服务，由于hexo支持git的部署方式，从而可以实现从本地更新博客，方便快捷。</p>
<h1 id="搭建流程"><a href="#搭建流程" class="headerlink" title="搭建流程"></a>搭建流程</h1><h2 id="1-本机安装Hexo"><a href="#1-本机安装Hexo" class="headerlink" title="1. 本机安装Hexo"></a>1. 本机安装Hexo</h2><blockquote>
<p>参见<a href="http://nibnait.com/9751cae7-Hello-World/">从零开始搭建Hexo静态博客</a></p>
</blockquote>
<h2 id="2-VPS上的操作"><a href="#2-VPS上的操作" class="headerlink" title="2. VPS上的操作"></a>2. VPS上的操作</h2><p>我的vps是在<a href="https://www.vultr.com/" target="_blank" rel="external">VULTR</a>上买的日本主机。CentOS 7 x64</p>
<h3 id="安装一些基本软件"><a href="#安装一些基本软件" class="headerlink" title="安装一些基本软件"></a>安装一些基本软件</h3><ul>
<li>yum update &amp;&amp; apt-get upgrade -y    #更新内核</li>
<li>yum install git -core</li>
<li>yum install gcc</li>
<li>yum install gcc-c++</li>
<li>yum install vim</li>
<li>yum install httpd</li>
</ul>
<h3 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h3><p><a href="http://www.cnblogs.com/zhoulf/archive/2013/02/09/2909653.html" target="_blank" rel="external">http://www.cnblogs.com/zhoulf/archive/2013/02/09/2909653.html</a></p>
<blockquote>
<ul>
<li>cd /usr/local</li>
</ul>
</blockquote>
<ol>
<li><p>安装OpenSSL</p>
<ul>
<li><p>wget <a href="https://www.openssl.org/source/openssl-1.0.2h.tar.gz" target="_blank" rel="external">https://www.openssl.org/source/openssl-1.0.2h.tar.gz</a></p>
</li>
<li><p>tar -zxvf openssl-1.0.2h.tar.gz</p>
</li>
<li>cd openssl-1.0.2h</li>
<li>./config –prefix=/usr/local/openssl –openssldir=/usr/local/openssl/conf</li>
<li>make &amp;&amp; make install</li>
<li>/usr/local/openssl/bin/openssl version -a </li>
</ul>
</li>
</ol>
<ol>
<li><p>安装PERC</p>
<ul>
<li><p>wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/</p>
</li>
<li><p>tar -zxvf pcre-8.37.tar.gz</p>
</li>
<li>cd pcre-8.37</li>
<li>./configure –prefix=/usr/local/pcre/</li>
<li>make &amp;&amp; make install</li>
</ul>
</li>
<li><p>安装zlib</p>
<ul>
<li><p>wget <a href="http://prdownloads.sourceforge.net/libpng/zlib-1.2.8.tar.gz?download" target="_blank" rel="external">http://prdownloads.sourceforge.net/libpng/zlib-1.2.8.tar.gz?download</a></p>
</li>
<li><p>tar -zxvf zlib-1.2.8.tar.gz</p>
</li>
<li>cd zlib-1.2.8</li>
<li>./configure –prefix=/usr/local/zlib/</li>
<li>make &amp;&amp; make install</li>
</ul>
</li>
<li><p>安装Nginx</p>
<ul>
<li>wget <a href="http://nginx.org/download/nginx-1.9.0.tar.gz" target="_blank" rel="external">http://nginx.org/download/nginx-1.9.0.tar.gz</a></li>
<li>添加www用户和组<br> groupadd www<br> useradd -g www www</li>
<li>创建网站根目录<br> mkdir -p     /var/www/root/<br> chmod -R 775 /var/www/root/  </li>
<li>tar -zxvf nginx-1.9.0.tar.gz</li>
<li>cd nginx-1.9.0</li>
<li>./configure \<br>–user=www \<br>–group=www \<br>–prefix=/usr/local/nginx \<br>–with-http_ssl_module \<br>–with-openssl=/usr/local/openssl-1.0.2h \<br>–with-pcre=/usr/local/pcre-8.37 \<br>–with-zlib=/usr/local/zlib-1.2.8 \<br>–with-http_stub_status_module \<br>–with-threads</li>
<li>make &amp;&amp; make install</li>
<li>/usr/local/nginx/sbin/nginx -V</li>
</ul>
</li>
</ol>
<pre><code>- 修改配置文件  
vim /usr/local/nginx/conf/nginx.conf
</code></pre><h3 id="新建git用户添加sudo权限"><a href="#新建git用户添加sudo权限" class="headerlink" title="新建git用户添加sudo权限"></a>新建git用户添加sudo权限</h3><ul>
<li>adduser git  </li>
<li>chmod 740 /etc/sudoers  </li>
<li>vim /etc/sudoers</li>
</ul>
<p>在vi编辑中找到如下内容：<br><figure class="highlight plain"><figcaption><span>Allow root to run any commands anywhere</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">root    ALL=(ALL)     ALL</div></pre></td></tr></table></figure></p>
<p>在其下面添加一行：<br><figure class="highlight plain"><figcaption><span>ALL=(ALL)     ALL```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">保存并退出后 执行</div><div class="line"> - chmod 440 /etc/sudoers</div><div class="line"></div><div class="line">### 创建Git仓库，并配置ssh登陆</div><div class="line"></div><div class="line"> - su git</div><div class="line"> - cd ~</div><div class="line"> - mkdir .ssh &amp;&amp; cd .ssh</div><div class="line"> - touch authorized_keys</div><div class="line"> - vi authorized_keys//粘贴本机 id_rsa.pub文件中key</div><div class="line"> - cd ~ </div><div class="line"> - mkdir hexo.git &amp;&amp; cd hexo.git</div><div class="line"> - git init --bare</div><div class="line"></div><div class="line">----</div><div class="line">测试一下，如果在```git bash```中输入```ssh git@VPS的IP地址```,能够远程登录的话，则表示设置成功了。</div><div class="line"></div><div class="line">失败！！！</div><div class="line"></div><div class="line">----</div><div class="line"></div><div class="line"></div><div class="line">### root用户下，创建网站目录并赋予git对网站目录的所有权</div><div class="line"></div><div class="line"> - cd /var/www</div><div class="line"> - mkdir hexo</div><div class="line"> - chown git:git -R /var/www/hexo</div><div class="line"></div><div class="line"></div><div class="line">### 配置git hooks</div><div class="line"></div><div class="line"> - su git</div><div class="line"> - cd /home/git/hexo.git/hooks</div><div class="line"> - vim post-receive</div><div class="line"></div><div class="line">输入如下内容后保存退出，</div><div class="line">	</div><div class="line">	#!/bin/bash</div><div class="line">	GIT_REPO=/home/git/hexo.git #git仓库</div><div class="line">	TMP_GIT_CLONE=/tmp/hexo</div><div class="line">	PUBLIC_WWW=/var/www/hexo #网站目录</div><div class="line">	rm -rf $&#123;TMP_GIT_CLONE&#125;</div><div class="line">	git clone $GIT_REPO $TMP_GIT_CLONE</div><div class="line">	rm -rf $&#123;PUBLIC_WWW&#125;/*</div><div class="line">	cp -rf $&#123;TMP_GIT_CLONE&#125;/* $&#123;PUBLIC_WWW&#125;</div><div class="line"></div><div class="line">然后赋予脚本的执行权限</div><div class="line"></div><div class="line"> - chmod +x post-receive</div><div class="line"></div><div class="line"></div><div class="line">### 配置Nginx</div><div class="line"></div><div class="line"> - vim /etc/nginx/conf.d/hexo.conf</div><div class="line"></div><div class="line">插入如下代码：</div></pre></td></tr></table></figure></p>
<p>server {<br>    listen         80 ;<br>    root /var/www/hexo;//这里可以改成你的网站目录地址，我将网站放在/var/www/hexo<br>    server_name example.com www.example.com;//这里输入你的域名或IP地址<br>    access_log  /var/log/nginx/hexo_access.log;<br>    error_log   /var/log/nginx/hexo_error.log;<br>    location ~<em> ^.+.(ico|gif|jpg|jpeg|png)$ {<br>            root /var/www/hexo;<br>            access_log   off;<br>            expires      1d;<br>    }<br>    location ~</em> ^.+.(css|js|txt|xml|swf|wav)$ {<br>        root /var/www/hexo;<br>        access_log   off;<br>        expires      10m;<br>    }<br>    location / {<br>        root /var/www/hexo;//这里可以改成你的网站目录地址，我将网站放在/var/www/hexo<br>        if (-f $request_filename) {<br>            rewrite ^/(.*)$  /$1 break;<br>        }<br>    }<br>}<br>```</p>
<p>重启Nginx</p>
<ul>
<li>service nginx restart</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://tiktoking.github.io/2016/01/26/hexo/#&quot;&gt;WikiLibrary | 在VPS上搭建hexo博客，利用git更新&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.hansoncoder.com/2016/03/02/VPS-building-Hexo/&quot;&gt;VPS(CentOS)搭建Hexo博客与Git Hooks更新（小白篇）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://hejun.me/2015/01/05/deploy-hexo-on-cloud/&quot;&gt;在云服务器上搭建HEXO博客环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/zhoulf/archive/2013/02/09/2909653.html&quot;&gt;Linux系统 - 源码编译安装Nginx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/d5114a2a2052&quot;&gt;Centos下 Nginx安装与配置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="工具配置笔记" scheme="http://nibnait.com/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CentOS" scheme="http://nibnait.com/tags/CentOS/"/>
    
      <category term="Linux" scheme="http://nibnait.com/tags/Linux/"/>
    
  </entry>
  
</feed>
